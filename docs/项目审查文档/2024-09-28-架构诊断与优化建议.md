# SynapseDB 项目优化建议（2024-09-28）

## 总览

整体架构围绕 `PersistentStore` 将增量数据与分页索引拆分，查询层通过 `QueryBuilder`/`StreamingQueryBuilder` 给出链式联想与属性检索，CLI 与维护脚本也较为齐全。现阶段的核心挑战主要集中在“索引重建与刷盘效率”“属性索引的重建策略”“CI 运行时资源消耗”三方面，需要在不破坏既有语义的前提下优化内存与 I/O 开销。

## 优先级建议概览

| 序号 | 优先级 | 主题                  | 关键问题                                                                           | 建议摘要                                                                                    |
| ---- | ------ | --------------------- | ---------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------- |
| 1    | P0     | 分页索引重建          | `buildPagedIndexes` 在六种顺序上重复全量读取主文件，导致 O(6N) I/O                 | 改为单次读取→多 writer 管线，或提前缓存三元组迭代器，降低重建时长与内存峰值                 |
| 2    | P0     | Flush 脏检查          | `flush()` 始终重写字典/属性，且通过 `serialize()` 判定是否有修改                   | 为 `StringDictionary`/`PropertyStore` 增加 `dirty` 标记与 `markClean()`，避免大文件频繁重写 |
| 3    | P1     | LSM 段合并            | `appendPagedIndexesFromStaging` 将 LSM 段一次性读入内存；大库场景会触发 >GB 缓冲   | 引入流式读取或分块拼接，并在 manifest 中记录处理进度，降低内存压力                          |
| 4    | P1     | 属性/标签索引重建策略 | `PersistentStore.open` 每次都 `rebuildPropertyIndex()`，对大属性集开销高           | 持久化增量索引状态（或追加 WAL），仅在检测到索引版本变化时全量重建                          |
| 5    | P1     | 查询层邻居访问        | `shortestPath*` 族函数对同一节点多次 `store.query()`，缺乏缓存并未复用分页扫描策略 | 抽象统一的邻居迭代器，支持 predicate 过滤与批量预取，减少热点节点反复查表                   |
| 6    | P1     | CI/测试耗时           | `pnpm ci` 同时执行 lint+coverage+build，且 `test:ci-seq-no-cov` 串行跑多域         | 引入基于改动范围的测试选择（Vitest related/changed），并拆分 CI job 以并行化耗时流程        |
| 7    | P2     | 覆盖率盲区            | `vitest.config.ts` 排除了 `src/spatial/**`、`src/fulltext/**`、`src/cli/**`        | 设计专项测试（可放 integration/perf 框架内）并逐步纳入覆盖率阈值                            |

## 架构与存储层

### 1. 索引重建重复读取（P0）

- 现状：`src/storage/persistentStore.ts` 的 `buildPagedIndexes` 在遍历 `orders` 时，每轮都 `readStorageFile(this.path)` 并 `TripleStore.deserialize()` 一次。对 6 个顺序意味着每次重建都会做 6 倍的文件解码与 GC，占据大量 I/O 与内存。
- 建议：将主文件读取外提，仅读取一次三元组流，随后并行推送到 6 个 `PagedIndexWriter`；或在首次读取后缓存到临时顺序文件，避免重复解码。同步关注 `pageSize` 调整场景下的重用逻辑，确保 manifest 写入只发生一次。

### 2. Flush 脏检查不准确（P0）

- 现状：`flush()` 通过 `this.dictionary.size > 0` 与 `Object.keys(this.properties.serialize()).length` 判断是否需要写主文件。由于缺少“是否有新写入”的信号，任何一次 flush 都会重写整个字典和属性段。
- 建议：为 `StringDictionary` 与 `PropertyStore` 增加 `isDirty` 标志，在 `getOrCreateId`/`set*Properties` 时置脏，写出后调用 `markClean()`。同时避免为了检测脏状态而调用 `serialize()` —— 可以直接维护累计计数或版本号。

### 3. LSM 段合并的内存压力（P1）

- 现状：`appendPagedIndexesFromStaging` 会把 `lsm-manifest.json` 中的所有段一次性读入到 `lsmTriples` 数组，再逐序写入分页索引；大段合并时可能一次拉入数十万条，造成堆占用飙升。
- 建议：改用逐段 streaming（例如利用 `PagedIndexWriter` 的追加接口，每次写一段即释放缓存），并在 manifest 上记录“已合并偏移”，支持断点续传。若结合 `flushLsmSegments` 同步写入 CRC，可在出现错误时跳过损坏段。

### 4. 属性/标签索引重建策略（P1）

- 现状：`PersistentStore.open()` 末尾始终调用 `rebuildPropertyIndex()` 与 `labelManager.rebuildFromNodeProperties()`，即使属性未变也会全量扫描。
- 建议：将属性索引持久化到 `indexDirectory`（例如 `props-index.json`），并维护版本号；当检测到主文件或 WAL 没有属性类变动时，仅加载已持久化的索引。若要保持安全，可在 WAL replay 阶段追加 PropertyChange 日志以驱动增量重建。

### 5. Tombstone 生命周期（附加）

- 现状：`this.tombstones` 在 `deleteFactDirect` 中只增不减，直到下一次 flush 才写入 manifest，长时间运行会扩散到成千上万条。
- 建议：考虑引入基于 epoch 的墓碑老化策略（例如 flush 后把已写入 manifest 的墓碑迁移到只读结构，或在 GC/compact 后清理无效 key），避免长时间运行后查询需频繁命中大 Set。

## 查询与算法层

### 6. 邻居访问复用（P1）

- 现状：`shortestPath` / `shortestPathBidirectional` / `shortestPathWeighted` 均直接调用 `this.store.query()`，对热点节点会重复读取同一主键下的页。虽然 `shortestPathBidirectional` 增加了 `forwardCache/backwardCache`，但缓存维度仅在方法内，无法复用分页扫描。
- 建议：提炼统一的邻居迭代器（例如 `store.iterNeighbors(nodeId, { direction, predicates })`）并利用分页索引 reader 的流式接口；缓存层可挂在 `StreamingQueryBuilder`，使多种算法共享预取结果。

### 7. 流式查询的增量合并（附加）

- 现状：`streamQuery` 流式读取分页数据后仍会 `this.triples.list()`，在大批插入后 flush 之前会复制整段内存。
- 建议：在 `TripleStore` 层提供批量迭代器（生成器），避免 `list()` 复制；或在 WAL 暂存阶段按主键聚合，便于快速合并。

## 工具链与测试

### 8. CI 资源占用（P1）

- 现状：`pnpm ci` 同时跑 `typecheck + lint + test:coverage + build`，`test:ci-seq-no-cov` 又串行执行多个目录，整体时长较长且对内存要求高。
- 建议：
  1. 利用 Vitest 的 `--changed`/`--related` 能力，在本地 pre-commit 仅执行受影响测试；
  2. CI pipeline 拆分为并行 Job（LINT / TEST / BUILD），并为覆盖率任务单独容器配置内存；
  3. 若覆盖率任务在 PR 中频繁 OOM，可在 workflow 中根据 diff 动态选择 `test:coverage` 或 `test:ci-seq-no-cov`。

### 9. 覆盖率盲区补齐（P2）

- 现状：`vitest.config.ts` 将 `src/spatial/**`、`src/fulltext/**`、`src/cli/**` 排除在覆盖率计算之外，长期缺乏验证。
- 建议：为空间查询/全文检索模块设计独立的性能或契约测试（可归类到 `tests/performance` 或 `tests/system`），确保核心写入/查询路径被回归覆盖，然后逐步放宽排除列表。

## 文档与运维

- 继续利用 `docs/测试分层与运行指南.md` 指导新加入的测试套件，建议补充“按组件运行”→“逐步纳入覆盖率”的行动表；
- 可以在 `docs/项目审查文档/` 维护定期的健康报告，与 `.qoder/repowiki` 输出做对比，确保智能体生成的外部文档有源可查。

---

以上建议聚焦于减少长时间运行下的内存/磁盘压力，并优化日常 CI 的执行效率；若按优先级推进，建议先落地索引构建与 flush 脏标记，再处理 CI 拆分与测试盲点。
