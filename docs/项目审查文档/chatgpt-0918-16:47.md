下面是**对 NervusDB 当前实现进度的“实事求是”评估**，以及是否达到你此前关心的“≈90% 完成度”、存在哪些不足与修复建议。为便于溯源，我对关键结论都附了仓库内代码/文档的行证（蓝色引用）。

---

## 结论（先给答案）

- **整体完成度：≈ 90%（±2%）**。
  从代码实现与测试覆盖看：单文件存储 + 分页索引（含 Brotli、CRC）、WAL v2 崩溃恢复与批次语义、链式联想查询、快照一致性、自动/增量合并与 GC、读者/热度治理等“核心面”已经齐备且互相打通【核心结构、原子落盘与分页清单写入：】【分页索引/清单结构与原子 rename+fsync：】【GC/Compaction/LSM 合并：】【快照 withSnapshot（epoch pin）：】【QueryBuilder 链式联想/where/limit/anchor：】【WAL 行为与 ABORT/恢复测试用例：】。
  你的最新一次 `pnpm test` 反馈显示 **83 个测试中 79 通过、4 失败**；测试通过率≈95%（但这不是“完成度”的直接等价），失败点集中在**锁混合模式语义**、**WAL 嵌套 ABORT**的边界语义与**manifest 写入性能**三处。
- **是否达到“你说的 90%”：达到了**。但要把“可用 Alpha”推到“可上线 Beta”，必须先把下面列出的 4 个红点修掉。

---

## 已落地的能力（摘要）

- **单文件存储 + 原子持久化**：主文件写入路径使用 `tmp → fsync → rename → fsync(dir)` 的崩溃安全序列，避免部分写与目录项未落盘导致的元数据丢失。【】
- **分页索引（六序）**：`.pages/` 目录保存多序（SPO/SOP/POS/PSO/OSP/OPS）分页文件与 `index-manifest.json`；页内可选 **Brotli** 压缩、页级 **CRC32** 校验；manifest 含 `epoch/tombstones/orphans` 字段用于读一致性与运维治理。【】
- **Compaction / GC / 热度驱动 / 读者治理**：
  - 增量与整序 compaction、记录孤页 `orphans`、并可**清理并入的 LSM 段**（`includeLsmSegments`）【】；
  - GC 过程中可选择 **respect readers**（检测 `readers.json` 的活跃读者而跳过）【】；
  - `hotness.json` 维护主键热度并支撑“热门优先”的自动合并【】。

- **WAL v2 + 批次/幂等 + 尾部截断**：
  - 测试用例覆盖“未 flush 写入靠 WAL 重放恢复”、“ABORT 后不应生效”、“尾部不完整安全截断”等【】。
  - 变更日志也明确了 `txId` 幂等与可选持久化去重、`BEGIN` 携带元信息等约定【】。

- **查询与读一致性**：`QueryBuilder` 支持 `follow/followReverse/where/limit/anchor`；`withSnapshot()` 固定 epoch，确保链式查询期间不受后台维护波动影响【】。
- **接口/选项层面**：`open()` 已支持 `enableLock / registerReader / stagingMode='lsm-lite'` 等开关（与读者治理、写锁和 LSM-lite 暂存对齐）【】。

---

## 当前不足与风险点（含可复现场景）

> 下列 4 个“P0 修复项”来自你贴出的失败用例与代码语义核对。

1. **锁混合模式：已上锁时，禁用锁的 writer 仍能打开（应拒绝）**

- 现象：`enableLock: true` 的实例已持有锁时，另一个 `enableLock: false` 的实例仍然 `open()` 成功（测试期待“拒绝”）——**语义缺口**：是否允许“无锁模式”绕过已存在的锁？测试选择**不允许**。
- 修复建议（语义统一）：即便传入 `enableLock: false`，**打开前也要探测锁哨兵**（锁文件/独占句柄）；若发现“有效锁且非本 PID”，一律抛出“database is locked”。
  **落点**：`PersistentStore.open()` 或锁模块初始化流程。伪补丁：

  ```ts
  // open(path, opts) 之初：
  const lock = readLockState(dbPath); // 读取锁文件/句柄（含PID）
  if (lock && !isSameProcess(lock.pid)) {
    // 不区分 enableLock，统一拒绝
    throw new Error('database is locked by another writer');
  }
  // 若 opts.enableLock === true 则尝试获取独占锁并写入/刷新锁文件
  ```

  相关接口痕迹：`enableLock` 与 `registerReader` 出现在对外选项【】；GC/维护也会读取读者注册信息【】。

2. **WAL 嵌套批次的部分 ABORT 语义不正确（两处失败）**

- 现象：
  - _嵌套_：外层批次中，内层 1 提交、内层 2 ABORT，重启后期望“外层提交 + 仅内层 1 生效”，但现在**数量少 1**。
  - _混合操作 ABORT_：在一个批次里“新增+删除+属性更新+再删除”后 ABORT，期望“全部回滚，仅保留初始事实”，而现在**多回滚了一个初始事实**（长度 0）。

- 根因推断：**重放器（以及运行时批次栈）缺少“分层栈”与合并/丢弃的精确定义**。BEGIN/COMMIT/ABORT 应维护**层级栈**：
  - `BEGIN(meta)`：`layers.push({ facts:[], dels:[], props:[], meta })`
  - `COMMIT`：`if (layers.length>1) merge(top, parent) else apply(top) & maybe persist txId`
  - `ABORT`：`discard(top)`
  - 重放时**只对“完整 COMMIT”落地**，对“未闭合批次”全部忽略（尾部截断已具备）【】。

- 修复要点：
  - **运行时**：`PersistentStore.begin/commit/abort` 内部已近似有状态，但需确保“内层 COMMIT → 合并到父层；外层 ABORT → 丢弃合并后的父层增量”。
  - **重放器**（`wal.ts`）：按上面“分层栈”模型实现；属性操作（node/edge props）同样进入层中并在 ABORT 时丢弃。
  - **幂等**：对带 `txId` 的外层 COMMIT 在“最外层落地”时记入去重集合（见 CHANGELOG 语义）【】。
  - 参考用例（语义目标）：`wal_abort_semantics.test.ts` 中 “ABORT 后不应生效”的断言已给出预期【】。

3. **`manifest` 写入性能在“小页大页数”下超时（5s）**

- 现状：`writePagedManifest()` 在多个版本中采用 `JSON.stringify(manifest, null, 2)`（美化 JSON）并 `tmp → fsync → rename → fsync(dir)`；大量页映射（小 pageSize）时，**格式化 JSON** 会放大串行化与写放大开销，触发测试超时【】。
- 立即可行的修复：**统一改为紧凑 JSON**（无缩进），仓库里已有一个“紧凑写入”的变体注释说明了动机【】。建议将所有实现归一为下面版本：

  ```ts
  export async function writePagedManifest(dir: string, m: PagedIndexManifest): Promise<void> {
    const file = join(dir, 'index-manifest.json');
    const tmp = `${file}.tmp`;
    const json = Buffer.from(JSON.stringify(m), 'utf8'); // 紧凑 JSON，降 IO 体积

    const fh = await fs.open(tmp, 'w');
    try {
      await fh.write(json, 0, json.length, 0);
      await fh.sync();
    } finally {
      await fh.close();
    }
    await fs.rename(tmp, file);
    try {
      const dh = await fs.open(dirname(file), 'r');
      try {
        await dh.sync();
      } finally {
        await dh.close();
      }
    } catch {}
  }
  ```

  如需进一步优化：为 `lookups.pages` 引入**定长二进制**或 **TypedArray** 序列化，manifest 仅存“段目录”，将巨量页元数据迁到 `.bin` 旁表以避免 JSON 爆炸。

4. **查询侧的小缺口：`where` 为结果集内存过滤，尚未“下推到属性/边索引”**

- 现在的 `where()` 是对已取回事实的**内存级过滤**，这对大图+属性过滤会有放大；若要做“属性谓词下推”，需要构建节点/边属性的倒排或二级索引。【`where/limit/anchor` 现状：】
- 这不是阻塞 Alpha 的 P0，但会影响大规模属性筛选的性能（纳入 P2 持续优化）。

---

## 和“目标蓝图”的差距（非 P0）

> 这些是设计文档标注的“阶段 3 / 优化项”，当前并非全部提供或只做了原型。

- **类型安全 Schema**、**内存映射（mmap）I/O**、**更重的 LSM-Tree**、**WASM/Rust 内核**等，设计文档把它们列在后续阶段【】。这些不影响你当前 Alpha 的正确性，但关系到性能/生态延展。

---

## 模块级完成度快照（主观估算）

| 模块                        | 结论    | 证据/备注                                                                   |
| --------------------------- | ------- | --------------------------------------------------------------------------- |
| 存储与落盘原子性            | **95%** | 主文件与 manifest 的 crash-safe 流水线已全；性能优化（紧凑 JSON）待统一【】 |
| 分页索引/六序/CRC/Brotli    | **95%** | 结构、读写与校验齐备【】                                                    |
| Compaction/GC/热度/读者治理 | **90%** | 机制完备、接口对齐；perf 与策略可继续迭代【】                               |
| WAL v2 + 批次/幂等/截断     | **85%** | 主线正确，但**嵌套 ABORT**语义需修复（见上）【】                            |
| 查询管线与快照一致性        | **90%** | 链式联想 + 快照 OK；属性下推未做【】                                        |
| 并发控制（写锁/读者）       | **85%** | 读者治理已接；**混合锁模式**需加“全局哨兵拒绝”【】                          |

> 以上取加权中位，得到 **≈ 90%（±2%）** 的整体完成度判断。

---

## 建议的修复顺序（落地 checklist）

**P0（先解红灯）**

1. **统一锁语义**：加入“无论 `enableLock` 与否，只要发现外部 writer 锁，就拒绝二次 writer 打开；同 PID 允许多次打开”的判断。补充一条回归：_“混合锁模式：已锁定时无锁模式仍被拒绝”_。
2. **WAL 嵌套语义重放器改造**：实现“批次栈”，按 _BEGIN →（内层若 COMMIT 则合入父层 / 若 ABORT 则丢弃）→ 外层 COMMIT 才落地_ 的规则；属性变更一并纳入栈。为 `txId` 的最外层 COMMIT 做去重落地（与 CHANGELOG 对齐）【】。补足高强度回归：嵌套 3 层 + 交错 ABORT/COMMIT + 重启恢复。
3. **Manifest 写入统一为紧凑 JSON** 并**去除所有 pretty-print** 的分支；必要时将 “页映射大对象” 拆分成二进制索引旁表，manifest 只存概要与偏移。追加性能基准：`pageSize=100`、50k+ 页映射，目标 < 2s。

**P1（重要优化）**
4\. **属性过滤“下推”原型**：对常用键建立轻量倒排（如节点属性 KV：`key->value->nodeId[]`），在 `where()` 识别可下推的谓词时，先取候选主语/宾语集合再走关系索引。
5\. **读者/治理的观测性**：增加 `db:readers`、`db:hotness --topN` 等 CLI 透视，便于线上问题定位。
6\. **lsm-lite → 段清单** 的可观测与阈值策略（写放大/读放大权衡）。

**P2（中期增强）**
7\. **mmap / Rust-WASM** 路线评估、类型安全 schema 与更重的查询优化器（含多谓词 join / 统计信息驱动）。

---

## 附：关键证据（节选）

- **manifest/分页索引结构与原子写入**：页 CRC、Brotli、`index-manifest.json`、`tmp→fsync→rename→fsync(dir)`【】
- **Compaction/GC/LSM 合并与读者尊重**：并入 LSM 段并清空清单；GC 支持 `respectReaders`【】
- **快照一致性**：`withSnapshot()` 固定 epoch（pin/unpin）【】
- **查询链路**：`follow/followReverse/where/limit/anchor`【】
- **WAL 行为（示例测试）**：未 flush 亦可重放恢复；ABORT 不应生效【】
- **开放选项**：`enableLock/registerReader/stagingMode`【】
- **设计阶段目标（类型安全、mmap、LSM、更强事务/优化器、WASM）**【】

---

如果你愿意，我可以把**锁与 WAL 重放器的修补 PR 草案**（含最小回归用例）直接按上面 checklist 写出来，方便你粘贴验证。
