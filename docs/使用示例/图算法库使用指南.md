# SynapseDB 图算法库使用指南

## 概述

SynapseDB 图算法库提供了丰富的图分析功能，包括中心性分析、社区发现、路径查找、相似度计算等。支持有向图和无向图，适用于社交网络分析、知识图谱分析、推荐系统等场景。

## 核心组件

### 1. 图数据结构

```typescript
import { MemoryGraph, GraphBuilder } from '@/algorithms/graph';
import { Node, Edge } from '@/algorithms/types';

// 创建内存图
const graph = new MemoryGraph();

// 使用构建器模式创建图
const graphBuilder = new GraphBuilder()
  .addNode('A', { name: '节点A', type: 'user' })
  .addNode('B', { name: '节点B', type: 'user' })
  .addNode('C', { name: '节点C', type: 'content' })
  .addEdge('A', 'B', 'follows', 1.0)
  .addEdge('B', 'C', 'likes', 0.8)
  .build();
```

### 2. 算法套件初始化

```typescript
import { GraphAlgorithmSuiteImpl } from '@/algorithms/suite';

// 创建算法套件
const algorithms = new GraphAlgorithmSuiteImpl(graph);

// 现在可以使用各种算法
console.log('节点数量:', algorithms.getNodeCount());
console.log('边数量:', algorithms.getEdgeCount());
```

## 中心性分析算法

### PageRank 算法

PageRank 用于评估节点在图中的重要性，最初用于 Google 搜索引擎排名。

```typescript
// 基础 PageRank 计算
const pageRankResult = algorithms.centrality.pageRank();

console.log('PageRank 分数:', pageRankResult.scores);
console.log('收敛统计:', pageRankResult.stats);

// 自定义参数的 PageRank
const customPageRank = algorithms.centrality.pageRank({
  dampingFactor: 0.85, // 阻尼因子，通常为 0.85
  maxIterations: 100, // 最大迭代次数
  tolerance: 1e-6, // 收敛容差
  personalization: new Map([
    // 个性化 PageRank
    ['A', 0.5], // 给节点 A 更高的初始权重
    ['B', 0.3],
  ]),
});

// 获取 Top-K 最重要的节点
const topNodes = Array.from(pageRankResult.scores.entries())
  .sort((a, b) => b[1] - a[1])
  .slice(0, 5);

console.log('Top 5 重要节点:', topNodes);
```

### 度中心性（Degree Centrality）

```typescript
// 计算度中心性
const degreeCentrality = algorithms.centrality.degreeCentrality();

console.log('度中心性:', degreeCentrality);

// 入度和出度中心性（有向图）
const inDegree = algorithms.centrality.inDegreeCentrality();
const outDegree = algorithms.centrality.outDegreeCentrality();

console.log('入度中心性:', inDegree);
console.log('出度中心性:', outDegree);
```

### 接近中心性（Closeness Centrality）

```typescript
// 计算接近中心性
const closenessCentrality = algorithms.centrality.closenessCentrality({
  normalized: true, // 是否归一化
  includeDisconnected: false, // 是否包含不连通的节点
});

console.log('接近中心性:', closenessCentrality);

// 针对特定节点计算
const nodeCloseness = algorithms.centrality.nodeClosenessCentrality('A');
console.log('节点 A 的接近中心性:', nodeCloseness);
```

### 中介中心性（Betweenness Centrality）

```typescript
// 计算中介中心性
const betweennessCentrality = algorithms.centrality.betweennessCentrality({
  normalized: true,
  endpoints: false, // 是否包含端点
  seed: 42, // 随机种子（用于大图的采样）
});

console.log('中介中心性:', betweennessCentrality);

// 边的中介中心性
const edgeBetweenness = algorithms.centrality.edgeBetweennessCentrality();
console.log('边中介中心性:', edgeBetweenness);
```

### 特征向量中心性（Eigenvector Centrality）

```typescript
// 计算特征向量中心性
const eigenvectorCentrality = algorithms.centrality.eigenvectorCentrality({
  maxIterations: 100,
  tolerance: 1e-6,
});

console.log('特征向量中心性:', eigenvectorCentrality.scores);
console.log('最大特征值:', eigenvectorCentrality.eigenvalue);
```

## 社区发现算法

### Louvain 算法

Louvain 算法是一种高效的社区发现算法，特别适合大规模网络。

```typescript
// 基础 Louvain 社区发现
const louvainResult = algorithms.community.louvain();

console.log('发现的社区数:', louvainResult.communityCount);
console.log('模块度:', louvainResult.modularity);
console.log('社区分配:', louvainResult.communities);

// 自定义参数的 Louvain
const customLouvain = algorithms.community.louvain({
  resolution: 1.0, // 分辨率参数，控制社区大小
  maxIterations: 100, // 最大迭代次数
  randomSeed: 42, // 随机种子
  minCommunitySize: 3, // 最小社区大小
});

// 分析社区结构
for (const [communityId, nodes] of customLouvain.communities) {
  console.log(`社区 ${communityId}: ${nodes.join(', ')}`);
}

// 计算社区内部连接密度
const communityDensities = new Map();
for (const [communityId, nodes] of customLouvain.communities) {
  const subgraph = graph.subgraph(nodes);
  const density = algorithms.metrics.density(subgraph);
  communityDensities.set(communityId, density);
}
```

### 标签传播算法（Label Propagation）

```typescript
// 基础标签传播
const labelPropResult = algorithms.community.labelPropagation();

console.log('标签分配:', labelPropResult.labels);
console.log('社区数:', labelPropResult.communityCount);

// 自定义参数的标签传播
const customLabelProp = algorithms.community.labelPropagation({
  maxIterations: 30,
  randomSeed: 42,
  asynchronous: true, // 是否使用异步更新
});
```

### Leiden 算法

Leiden 算法是 Louvain 算法的改进版本，提供更好的社区质量。

```typescript
// Leiden 社区发现
const leidenResult = algorithms.community.leiden({
  resolution: 1.0,
  maxIterations: 100,
  nIterationsMove: 10, // 移动阶段的迭代次数
  randomSeed: 42,
});

console.log('Leiden 结果:', leidenResult);
```

### 层次聚类

```typescript
// 基于相似度的层次聚类
const hierarchicalResult = algorithms.community.hierarchicalClustering({
  linkage: 'average', // 连接准则: 'single', 'complete', 'average'
  metric: 'jaccard', // 距离度量: 'jaccard', 'cosine', 'euclidean'
  threshold: 0.5, // 聚类阈值
});

console.log('层次聚类树:', hierarchicalResult.dendrogram);
```

## 路径算法

### Dijkstra 最短路径

```typescript
// 从单个源点计算最短路径
const shortestPaths = algorithms.path.dijkstra('A');
console.log('从 A 到所有节点的最短路径:', shortestPaths);

// 计算两点间最短路径
const pathAtoC = algorithms.path.dijkstraPath('A', 'C');
console.log('A 到 C 的最短路径:', pathAtoC);

// 带权重的最短路径
const weightedPaths = algorithms.path.dijkstra('A', {
  weightAttribute: 'weight', // 使用边的权重属性
  maxDistance: 10, // 最大搜索距离
});
```

### A\* 路径搜索

A\* 算法结合了 Dijkstra 算法和启发式搜索，适用于有明确目标的路径搜索。

```typescript
// A* 路径搜索（需要启发式函数）
const astarPath = algorithms.path.aStar('A', 'D', (node, target) => {
  // 简单的启发式函数：节点ID的字母距离
  return Math.abs(node.charCodeAt(0) - target.charCodeAt(0));
});

console.log('A* 路径:', astarPath);

// 带坐标的 A* 搜索
const geographicAStar = algorithms.path.aStar('start', 'end', (nodeId, targetId) => {
  const nodePos = graph.getNode(nodeId)?.value?.position;
  const targetPos = graph.getNode(targetId)?.value?.position;

  if (!nodePos || !targetPos) return 0;

  // 欧几里得距离作为启发式
  return Math.sqrt(Math.pow(nodePos.x - targetPos.x, 2) + Math.pow(nodePos.y - targetPos.y, 2));
});
```

### 双向搜索

```typescript
// 双向 Dijkstra 搜索
const bidirectionalPath = algorithms.path.bidirectionalDijkstra('A', 'Z');
console.log('双向搜索路径:', bidirectionalPath);

// 双向 BFS 搜索
const bidirectionalBFS = algorithms.path.bidirectionalBFS('A', 'Z');
console.log('双向 BFS 路径:', bidirectionalBFS);
```

### K 最短路径

```typescript
// 计算 K 条最短路径
const kPaths = algorithms.path.kShortestPaths('A', 'D', 3);
console.log('3 条最短路径:', kPaths);

// Yen 算法计算 K 最短路径
const yenPaths = algorithms.path.yenKShortestPaths('A', 'D', 5);
console.log('Yen 算法结果:', yenPaths);
```

## 相似度计算

### Jaccard 相似度

```typescript
// 计算两个节点的 Jaccard 相似度
const jaccardSim = algorithms.similarity.jaccard('A', 'B');
console.log('Jaccard 相似度:', jaccardSim);

// 批量计算相似度矩阵
const jaccardMatrix = algorithms.similarity.jaccardMatrix(['A', 'B', 'C', 'D']);
console.log('Jaccard 相似度矩阵:', jaccardMatrix);

// 基于共同邻居的相似度
const commonNeighborsSim = algorithms.similarity.commonNeighbors('A', 'B');
console.log('共同邻居相似度:', commonNeighborsSim);
```

### 余弦相似度

```typescript
// 余弦相似度计算
const cosineSim = algorithms.similarity.cosine('A', 'B');
console.log('余弦相似度:', cosineSim);

// 基于节点属性的余弦相似度
const attributeCosineSim = algorithms.similarity.cosineAttribute('A', 'B', 'features');
console.log('属性余弦相似度:', attributeCosineSim);
```

### 结构相似度

```typescript
// SimRank 相似度
const simRankResults = algorithms.similarity.simRank({
  maxIterations: 10,
  dampingFactor: 0.8,
  tolerance: 1e-4,
});

console.log('SimRank 相似度:', simRankResults);

// 基于路径的相似度
const pathSimilarity = algorithms.similarity.pathSimilarity('A', 'B', {
  maxPathLength: 3,
  pathWeightDecay: 0.5,
});

console.log('路径相似度:', pathSimilarity);
```

## 图度量和分析

### 基础图统计

```typescript
// 图的基础统计信息
const basicStats = {
  nodeCount: algorithms.getNodeCount(),
  edgeCount: algorithms.getEdgeCount(),
  density: algorithms.metrics.density(),
  averageDegree: algorithms.metrics.averageDegree(),
  maxDegree: algorithms.metrics.maxDegree(),
  minDegree: algorithms.metrics.minDegree(),
};

console.log('基础统计:', basicStats);
```

### 连通性分析

```typescript
// 检查图的连通性
const connectivity = {
  isConnected: algorithms.connectivity.isConnected(),
  componentCount: algorithms.connectivity.connectedComponents().length,
  largestComponent: algorithms.connectivity.largestConnectedComponent(),
  bridges: algorithms.connectivity.bridges(),
  articulationPoints: algorithms.connectivity.articulationPoints(),
};

console.log('连通性分析:', connectivity);

// 强连通分量（有向图）
const stronglyConnected = algorithms.connectivity.stronglyConnectedComponents();
console.log('强连通分量:', stronglyConnected);
```

### 聚类系数

```typescript
// 全局聚类系数
const globalClustering = algorithms.metrics.globalClusteringCoefficient();
console.log('全局聚类系数:', globalClustering);

// 局部聚类系数
const localClustering = algorithms.metrics.localClusteringCoefficient();
console.log('局部聚类系数:', localClustering);

// 平均聚类系数
const avgClustering = algorithms.metrics.averageClusteringCoefficient();
console.log('平均聚类系数:', avgClustering);
```

### 图直径和半径

```typescript
// 计算图的直径和半径
const diameterInfo = {
  diameter: algorithms.metrics.diameter(),
  radius: algorithms.metrics.radius(),
  center: algorithms.metrics.center(),
  periphery: algorithms.metrics.periphery(),
};

console.log('图的几何性质:', diameterInfo);
```

## 高级算法应用

### 链路预测

```typescript
// 基于共同邻居的链路预测
const linkPrediction = algorithms.linkPrediction.commonNeighbors();

// 基于 Adamic-Adar 指数的链路预测
const adamicAdarScores = algorithms.linkPrediction.adamicAdar();

// 基于资源分配指数的链路预测
const resourceAllocationScores = algorithms.linkPrediction.resourceAllocation();

// 综合评分
const combinedScores = new Map();
for (const [pair, cnScore] of linkPrediction) {
  const aaScore = adamicAdarScores.get(pair) || 0;
  const raScore = resourceAllocationScores.get(pair) || 0;

  combinedScores.set(pair, {
    commonNeighbors: cnScore,
    adamicAdar: aaScore,
    resourceAllocation: raScore,
    combined: cnScore * 0.4 + aaScore * 0.3 + raScore * 0.3,
  });
}

console.log('链路预测结果:', combinedScores);
```

### 影响力传播

```typescript
// 独立级联模型
const cascadeResult = algorithms.influence.independentCascade({
  seedNodes: ['A', 'B'], // 种子节点
  activationProbability: 0.1, // 激活概率
  maxSteps: 10, // 最大传播步数
  simulations: 100, // 蒙特卡罗模拟次数
});

console.log('影响力传播结果:', cascadeResult);

// 线性阈值模型
const thresholdResult = algorithms.influence.linearThreshold({
  seedNodes: ['A', 'B'],
  threshold: 0.5, // 激活阈值
  maxSteps: 10,
});

console.log('线性阈值模型结果:', thresholdResult);
```

### 动态图分析

```typescript
// 创建时间序列图
const timeSeriesGraphs = new Map();
timeSeriesGraphs.set(1, graph1);
timeSeriesGraphs.set(2, graph2);
timeSeriesGraphs.set(3, graph3);

// 分析图的演化
const evolution = algorithms.temporal.analyzeEvolution(timeSeriesGraphs);

console.log('图演化分析:', evolution);

// 检测社区演化
const communityEvolution = algorithms.temporal.trackCommunities(timeSeriesGraphs);
console.log('社区演化:', communityEvolution);
```

## 性能优化和最佳实践

### 大图处理

```typescript
// 对于大图，使用采样算法
const sampledPageRank = algorithms.centrality.pageRank({
  maxIterations: 50,
  sampleSize: 1000, // 采样大小
  samplingMethod: 'random', // 采样方法
});

// 使用并行计算
const parallelResult = algorithms.centrality.parallelBetweennessCentrality({
  workers: 4, // 工作线程数
  chunkSize: 100, // 每个块的大小
});
```

### 内存管理

```typescript
// 设置内存限制
algorithms.setMemoryLimit(1024 * 1024 * 1024); // 1GB

// 启用内存优化模式
algorithms.enableMemoryOptimization({
  useCompression: true, // 使用压缩
  lazyEvaluation: true, // 延迟计算
  cacheResults: false, // 不缓存中间结果
});

// 定期清理内存
setInterval(() => {
  algorithms.cleanup();
}, 60000); // 每分钟清理一次
```

### 算法选择指南

```typescript
// 根据图的特性选择合适的算法
function chooseAlgorithm(graph) {
  const nodeCount = graph.nodeCount;
  const edgeCount = graph.edgeCount;
  const density = edgeCount / (nodeCount * (nodeCount - 1));

  if (nodeCount < 1000) {
    return 'exact'; // 精确算法
  } else if (nodeCount < 100000) {
    return 'approximate'; // 近似算法
  } else {
    return 'sampling'; // 采样算法
  }
}

const algorithmType = chooseAlgorithm(graph);
console.log('推荐算法类型:', algorithmType);
```

## 可视化和导出

### 图数据导出

```typescript
// 导出为不同格式
const gexfExport = algorithms.export.toGEXF();
const graphmlExport = algorithms.export.toGraphML();
const dotExport = algorithms.export.toDOT();
const jsonExport = algorithms.export.toJSON();

// 导出算法结果
const resultsExport = {
  pagerank: pageRankResult.scores,
  communities: louvainResult.communities,
  centrality: degreeCentrality,
};

console.log('导出结果:', resultsExport);
```

### 性能基准测试

```typescript
import { runGraphAlgorithmsBenchmark } from '@/benchmark';

// 运行图算法性能测试
const benchmarkResults = await runGraphAlgorithmsBenchmark();
console.log('图算法性能基准:', benchmarkResults);

// 自定义基准测试
const customBenchmark = await algorithms.benchmark({
  algorithms: ['pagerank', 'louvain', 'dijkstra'],
  iterations: 10,
  warmup: 3,
});

console.log('自定义基准测试:', customBenchmark);
```

## 实际应用示例

### 社交网络分析

```typescript
async function analyzeSocialNetwork(socialGraph) {
  // 1. 识别意见领袖
  const pageRank = algorithms.centrality.pageRank();
  const influencers = Array.from(pageRank.scores.entries())
    .sort((a, b) => b[1] - a[1])
    .slice(0, 10);

  // 2. 发现社区
  const communities = algorithms.community.louvain();

  // 3. 分析网络结构
  const networkStats = {
    clustering: algorithms.metrics.averageClusteringCoefficient(),
    diameter: algorithms.metrics.diameter(),
    density: algorithms.metrics.density(),
  };

  // 4. 链路预测
  const potentialConnections = algorithms.linkPrediction.adamicAdar();

  return {
    influencers,
    communities,
    networkStats,
    potentialConnections,
  };
}
```

### 知识图谱分析

```typescript
async function analyzeKnowledgeGraph(knowledgeGraph) {
  // 1. 实体重要性排名
  const entityImportance = algorithms.centrality.pageRank({
    personalization: new Map([
      ['Person', 1.5], // 人物实体更重要
      ['Organization', 1.2], // 组织实体次之
      ['Event', 1.0], // 事件实体正常权重
    ]),
  });

  // 2. 概念聚类
  const conceptClusters = algorithms.community.leiden({
    resolution: 0.5,
  });

  // 3. 语义相似度
  const semanticSimilarity = algorithms.similarity.simRank({
    maxIterations: 20,
  });

  // 4. 路径推理
  const reasoningPaths = algorithms.path.kShortestPaths('concept1', 'concept2', 5);

  return {
    entityImportance,
    conceptClusters,
    semanticSimilarity,
    reasoningPaths,
  };
}
```

通过这个详细的指南，你可以充分利用 SynapseDB 的图算法库，进行各种复杂的图数据分析和挖掘任务。
