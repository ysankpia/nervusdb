# SynapseDB 空间几何计算指南

## 概述

SynapseDB 空间几何模块提供了完整的地理空间数据处理功能，兼容 GeoJSON 标准，支持点、线、多边形等几何对象的创建、分析和计算。适用于地理信息系统（GIS）、位置服务、空间数据分析等应用场景。

## 核心组件

### 1. 几何数据类型

```typescript
import {
  Point,
  LineString,
  Polygon,
  MultiPoint,
  MultiLineString,
  MultiPolygon,
  GeometryCollection,
} from '@/spatial/types';

// 点（Point）
const beijing: Point = {
  type: 'Point',
  coordinates: [116.4074, 39.9042], // [经度, 纬度]
};

// 线串（LineString）
const route: LineString = {
  type: 'LineString',
  coordinates: [
    [116.4074, 39.9042], // 北京
    [121.4737, 31.2304], // 上海
    [113.2644, 23.1291], // 广州
  ],
};

// 多边形（Polygon）
const region: Polygon = {
  type: 'Polygon',
  coordinates: [
    [
      // 外环
      [116.3, 39.8],
      [116.5, 39.8],
      [116.5, 40.0],
      [116.3, 40.0],
      [116.3, 39.8], // 闭合
    ],
    [
      // 内环（洞）
      [116.35, 39.85],
      [116.45, 39.85],
      [116.45, 39.95],
      [116.35, 39.95],
      [116.35, 39.85],
    ],
  ],
};
```

### 2. 空间几何计算引擎

```typescript
import { SpatialGeometryImpl } from '@/spatial/geometry';

// 创建空间计算实例
const spatial = new SpatialGeometryImpl();

// 基础几何验证
const isValid = spatial.isValid(beijing);
console.log('几何对象是否有效:', isValid);

// 修复无效几何
const fixed = spatial.makeValid(invalidGeometry);
console.log('修复后的几何对象:', fixed);
```

## 距离计算

### 两点间距离

```typescript
const beijing: Point = {
  type: 'Point',
  coordinates: [116.4074, 39.9042],
};

const shanghai: Point = {
  type: 'Point',
  coordinates: [121.4737, 31.2304],
};

// 计算距离（默认单位：米）
const distanceMeters = spatial.distance(beijing, shanghai);
console.log(`距离: ${(distanceMeters / 1000).toFixed(2)} km`);

// 不同单位的距离计算
const distanceKm = spatial.distance(beijing, shanghai, 'kilometers');
const distanceMiles = spatial.distance(beijing, shanghai, 'miles');
const distanceFeet = spatial.distance(beijing, shanghai, 'feet');
const distanceNautical = spatial.distance(beijing, shanghai, 'nautical_miles');

console.log(`距离: ${distanceKm.toFixed(2)} km`);
console.log(`距离: ${distanceMiles.toFixed(2)} miles`);
console.log(`距离: ${distanceFeet.toFixed(2)} feet`);
console.log(`距离: ${distanceNautical.toFixed(2)} nautical miles`);
```

### 复杂几何对象距离

```typescript
// 点到线的距离
const point: Point = { type: 'Point', coordinates: [116.4, 39.9] };
const line: LineString = {
  type: 'LineString',
  coordinates: [
    [116.3, 39.8],
    [116.5, 40.0],
  ],
};

const pointToLineDistance = spatial.distance(point, line);
console.log('点到线距离:', pointToLineDistance);

// 点到多边形的距离
const polygon: Polygon = {
  type: 'Polygon',
  coordinates: [
    [
      [116.2, 39.7],
      [116.6, 39.7],
      [116.6, 40.1],
      [116.2, 40.1],
      [116.2, 39.7],
    ],
  ],
};

const pointToPolygonDistance = spatial.distance(point, polygon);
console.log('点到多边形距离:', pointToPolygonDistance);
```

## 面积和长度计算

### 面积计算

```typescript
// 计算多边形面积
const area = spatial.area(polygon, 'kilometers'); // 平方公里
console.log(`面积: ${area.toFixed(2)} km²`);

// 不同单位的面积
const areaMeters = spatial.area(polygon, 'meters'); // 平方米
const areaMiles = spatial.area(polygon, 'miles'); // 平方英里
const areaFeet = spatial.area(polygon, 'feet'); // 平方英尺

console.log(`面积: ${areaMeters.toFixed(2)} m²`);
console.log(`面积: ${areaMiles.toFixed(6)} mi²`);
console.log(`面积: ${areaFeet.toFixed(2)} ft²`);

// 复杂多边形（带洞）
const complexPolygon: Polygon = {
  type: 'Polygon',
  coordinates: [
    [
      // 外环
      [0, 0],
      [10, 0],
      [10, 10],
      [0, 10],
      [0, 0],
    ],
    [
      // 洞1
      [2, 2],
      [4, 2],
      [4, 4],
      [2, 4],
      [2, 2],
    ],
    [
      // 洞2
      [6, 6],
      [8, 6],
      [8, 8],
      [6, 8],
      [6, 6],
    ],
  ],
};

const complexArea = spatial.area(complexPolygon);
console.log('复杂多边形面积（扣除洞）:', complexArea);
```

### 长度计算

```typescript
// 计算线串长度
const route: LineString = {
  type: 'LineString',
  coordinates: [
    [116.4074, 39.9042], // 北京
    [117.2, 39.1], // 天津
    [121.4737, 31.2304], // 上海
  ],
};

const routeLength = spatial.length(route, 'kilometers');
console.log(`路线总长度: ${routeLength.toFixed(2)} km`);

// 多边形周长
const perimeter = spatial.length(polygon, 'meters');
console.log(`多边形周长: ${perimeter.toFixed(2)} m`);

// 多条线串的总长度
const multiLine: MultiLineString = {
  type: 'MultiLineString',
  coordinates: [
    [
      [116.4, 39.9],
      [117.2, 39.1],
    ], // 线段1
    [
      [117.2, 39.1],
      [121.5, 31.2],
    ], // 线段2
  ],
};

const totalLength = spatial.length(multiLine);
console.log('多线串总长度:', totalLength);
```

## 边界框和中心点

### 边界框计算

```typescript
// 计算几何对象的边界框
const bounds = spatial.bounds(polygon);
console.log('边界框 [minX, minY, maxX, maxY]:', bounds);

const [minX, minY, maxX, maxY] = bounds;
console.log(`西南角: (${minX}, ${minY})`);
console.log(`东北角: (${maxX}, ${maxY})`);

// 创建边界框多边形
const boundingBox: Polygon = {
  type: 'Polygon',
  coordinates: [
    [
      [minX, minY],
      [maxX, minY],
      [maxX, maxY],
      [minX, maxY],
      [minX, minY],
    ],
  ],
};
```

### 中心点计算

```typescript
// 计算边界框中心
const center = spatial.center(polygon);
console.log('几何中心:', center);

// 计算质心（重心）
const centroid = spatial.centroid(polygon);
console.log('质心:', centroid);

// 不同几何类型的中心点
const lineCenter = spatial.center(route);
const lineCentroid = spatial.centroid(route);
console.log('线串中心:', lineCenter);
console.log('线串质心:', lineCentroid);
```

## 几何关系判断

### 包含关系

```typescript
// 判断点是否在多边形内
const testPoint: Point = { type: 'Point', coordinates: [116.4, 39.9] };
const isInside = spatial.contains(polygon, testPoint);
console.log('点是否在多边形内:', isInside);

// 判断一个多边形是否完全包含另一个
const smallPolygon: Polygon = {
  type: 'Polygon',
  coordinates: [
    [
      [116.35, 39.85],
      [116.45, 39.85],
      [116.45, 39.95],
      [116.35, 39.95],
      [116.35, 39.85],
    ],
  ],
};

const contains = spatial.contains(polygon, smallPolygon);
console.log('大多边形是否包含小多边形:', contains);
```

### 相交检测

```typescript
// 检查两个几何对象是否相交
const polygon1: Polygon = {
  type: 'Polygon',
  coordinates: [
    [
      [116.3, 39.8],
      [116.5, 39.8],
      [116.5, 40.0],
      [116.3, 40.0],
      [116.3, 39.8],
    ],
  ],
};

const polygon2: Polygon = {
  type: 'Polygon',
  coordinates: [
    [
      [116.4, 39.9],
      [116.6, 39.9],
      [116.6, 40.1],
      [116.4, 40.1],
      [116.4, 39.9],
    ],
  ],
};

const intersects = spatial.intersects(polygon1, polygon2);
console.log('两个多边形是否相交:', intersects);

// 线与多边形相交
const crossingLine: LineString = {
  type: 'LineString',
  coordinates: [
    [116.2, 39.9],
    [116.6, 39.9],
  ],
};

const lineIntersectsPolygon = spatial.intersects(crossingLine, polygon1);
console.log('线是否与多边形相交:', lineIntersectsPolygon);
```

## 几何运算

### 交集计算

```typescript
// 计算两个多边形的交集
const intersection = spatial.intersection(polygon1, polygon2);

if (intersection) {
  console.log('交集几何:', intersection);
  const intersectionArea = spatial.area(intersection);
  console.log('交集面积:', intersectionArea);
} else {
  console.log('两个多边形不相交');
}
```

### 并集计算

```typescript
// 计算两个多边形的并集
const union = spatial.union(polygon1, polygon2);
console.log('并集几何:', union);

const unionArea = spatial.area(union);
console.log('并集面积:', unionArea);

// 验证并集面积公式：A ∪ B = A + B - A ∩ B
const area1 = spatial.area(polygon1);
const area2 = spatial.area(polygon2);
const intersectionArea = intersection ? spatial.area(intersection) : 0;
const calculatedUnionArea = area1 + area2 - intersectionArea;

console.log('验算并集面积:', calculatedUnionArea);
```

### 缓冲区生成

```typescript
// 为点生成缓冲区
const pointBuffer = spatial.buffer(beijing, 1000, 'meters'); // 1km 缓冲区
console.log('点的1km缓冲区:', pointBuffer);

// 为线生成缓冲区
const lineBuffer = spatial.buffer(route, 500, 'meters'); // 500m 缓冲区
console.log('线的500m缓冲区:', lineBuffer);

// 为多边形生成缓冲区
const polygonBuffer = spatial.buffer(polygon, 200, 'meters'); // 200m 缓冲区
console.log('多边形的200m缓冲区:', polygonBuffer);

// 不同单位的缓冲区
const bufferKm = spatial.buffer(beijing, 5, 'kilometers');
const bufferMiles = spatial.buffer(beijing, 1, 'miles');
const bufferFeet = spatial.buffer(beijing, 1000, 'feet');

console.log('5km 缓冲区:', bufferKm);
console.log('1英里 缓冲区:', bufferMiles);
console.log('1000英尺 缓冲区:', bufferFeet);
```

## 几何简化和处理

### 几何简化

```typescript
// 使用 Douglas-Peucker 算法简化几何
const detailedLine: LineString = {
  type: 'LineString',
  coordinates: [
    [116.4, 39.9],
    [116.41, 39.91],
    [116.42, 39.91],
    [116.43, 39.92],
    [116.44, 39.92],
    [116.45, 39.93],
    [116.46, 39.93],
    [116.47, 39.94],
    [116.48, 39.95],
  ],
};

// 简化线串（容差越大，简化程度越高）
const simplified = spatial.simplify(detailedLine, 0.01);
console.log('简化前点数:', detailedLine.coordinates.length);
console.log('简化后点数:', simplified.coordinates.length);

// 简化多边形
const simplifiedPolygon = spatial.simplify(polygon, 0.001);
console.log('简化后的多边形:', simplifiedPolygon);
```

### 坐标系处理

```typescript
import { GeometryUtils } from '@/spatial/geometry';

// 坐标验证和归一化
const coordinate = [181, 91]; // 超出有效范围的坐标
const isValidCoord = GeometryUtils.isValidCoordinate(coordinate);
console.log('坐标是否有效:', isValidCoord);

const normalizedCoord = GeometryUtils.normalizeCoordinate(coordinate);
console.log('归一化后的坐标:', normalizedCoord);

// 角度和弧度转换
const degrees = GeometryUtils.toDegrees(Math.PI / 2);
const radians = GeometryUtils.toRadians(90);
console.log('π/2 弧度 =', degrees, '度');
console.log('90 度 =', radians, '弧度');
```

### 方位角和目标点计算

```typescript
// 计算两点间的方位角
const bearing = GeometryUtils.bearing(
  [116.4074, 39.9042], // 北京
  [121.4737, 31.2304], // 上海
);
console.log('北京到上海的方位角:', bearing, '度');

// 根据起点、方位角和距离计算终点
const destination = GeometryUtils.destination(
  [116.4074, 39.9042], // 起点：北京
  90, // 方位角：正东方向
  100000, // 距离：100km
);
console.log('北京正东100km处的坐标:', destination);
```

## 高级几何分析

### 复杂多边形分析

```typescript
// 分析多边形的复杂性
function analyzePolygon(polygon: Polygon) {
  const area = spatial.area(polygon, 'kilometers');
  const perimeter = spatial.length(polygon, 'kilometers');
  const bounds = spatial.bounds(polygon);
  const center = spatial.center(polygon);
  const centroid = spatial.centroid(polygon);

  // 计算形状指数
  const shapeIndex = (perimeter * perimeter) / (4 * Math.PI * area);
  const compactness = area / (perimeter * perimeter);

  return {
    area: area.toFixed(3) + ' km²',
    perimeter: perimeter.toFixed(3) + ' km',
    bounds,
    center,
    centroid,
    shapeIndex: shapeIndex.toFixed(3), // 接近1表示形状接近圆形
    compactness: compactness.toFixed(6), // 越大表示越紧凑
  };
}

const analysis = analyzePolygon(polygon);
console.log('多边形分析结果:', analysis);
```

### 空间聚类分析

```typescript
// 基于距离的点聚类
function spatialClustering(points: Point[], maxDistance: number) {
  const clusters: Point[][] = [];
  const visited = new Set<number>();

  for (let i = 0; i < points.length; i++) {
    if (visited.has(i)) continue;

    const cluster: Point[] = [points[i]];
    visited.add(i);

    for (let j = i + 1; j < points.length; j++) {
      if (visited.has(j)) continue;

      const distance = spatial.distance(points[i], points[j]);
      if (distance <= maxDistance) {
        cluster.push(points[j]);
        visited.add(j);
      }
    }

    clusters.push(cluster);
  }

  return clusters;
}

const points: Point[] = [
  { type: 'Point', coordinates: [116.4, 39.9] },
  { type: 'Point', coordinates: [116.41, 39.91] },
  { type: 'Point', coordinates: [121.47, 31.23] },
  { type: 'Point', coordinates: [121.48, 31.24] },
];

const clusters = spatialClustering(points, 5000); // 5km 聚类半径
console.log('空间聚类结果:', clusters);
```

### 空间索引应用

```typescript
// 简单的空间索引实现（网格索引）
class SpatialIndex {
  private gridSize: number;
  private grid: Map<string, Point[]>;

  constructor(gridSize: number = 0.01) {
    // 0.01度的网格
    this.gridSize = gridSize;
    this.grid = new Map();
  }

  // 添加点到索引
  addPoint(point: Point): void {
    const key = this.getGridKey(point.coordinates);
    if (!this.grid.has(key)) {
      this.grid.set(key, []);
    }
    this.grid.get(key)!.push(point);
  }

  // 查询附近的点
  queryNearby(center: Point, radius: number): Point[] {
    const nearby: Point[] = [];
    const centerKey = this.getGridKey(center.coordinates);

    // 检查周围的网格
    for (let dx = -1; dx <= 1; dx++) {
      for (let dy = -1; dy <= 1; dy++) {
        const [centerX, centerY] = this.parseGridKey(centerKey);
        const checkKey = this.formatGridKey(centerX + dx, centerY + dy);

        const gridPoints = this.grid.get(checkKey) || [];
        for (const point of gridPoints) {
          const distance = spatial.distance(center, point);
          if (distance <= radius) {
            nearby.push(point);
          }
        }
      }
    }

    return nearby;
  }

  private getGridKey(coordinates: [number, number]): string {
    const [lon, lat] = coordinates;
    const gridX = Math.floor(lon / this.gridSize);
    const gridY = Math.floor(lat / this.gridSize);
    return this.formatGridKey(gridX, gridY);
  }

  private formatGridKey(x: number, y: number): string {
    return `${x},${y}`;
  }

  private parseGridKey(key: string): [number, number] {
    const [x, y] = key.split(',').map(Number);
    return [x, y];
  }
}

// 使用空间索引
const spatialIndex = new SpatialIndex(0.01);

// 添加点到索引
points.forEach((point) => spatialIndex.addPoint(point));

// 查询北京附近5km内的点
const nearbyPoints = spatialIndex.queryNearby(beijing, 5000);
console.log('北京附近5km内的点:', nearbyPoints);
```

## 实际应用示例

### 地理围栏应用

```typescript
class GeoFence {
  private boundary: Polygon;
  private spatial: SpatialGeometryImpl;

  constructor(boundary: Polygon) {
    this.boundary = boundary;
    this.spatial = new SpatialGeometryImpl();
  }

  // 检查点是否在围栏内
  isInside(point: Point): boolean {
    return this.spatial.contains(this.boundary, point);
  }

  // 计算点到围栏边界的距离
  distanceToBoundary(point: Point): number {
    if (this.isInside(point)) {
      return 0; // 在围栏内
    }
    return this.spatial.distance(point, this.boundary);
  }

  // 创建缓冲区围栏
  createBufferFence(bufferDistance: number): Polygon {
    return this.spatial.buffer(this.boundary, bufferDistance, 'meters') as Polygon;
  }

  // 获取进入/离开事件
  checkMovement(
    previousPoint: Point,
    currentPoint: Point,
  ): 'enter' | 'exit' | 'inside' | 'outside' {
    const wasInside = this.isInside(previousPoint);
    const isInside = this.isInside(currentPoint);

    if (!wasInside && isInside) return 'enter';
    if (wasInside && !isInside) return 'exit';
    if (isInside) return 'inside';
    return 'outside';
  }
}

// 创建围栏
const fence = new GeoFence(polygon);

// 测试点
const testPoints = [
  { type: 'Point' as const, coordinates: [116.4, 39.9] }, // 围栏内
  { type: 'Point' as const, coordinates: [116.1, 39.7] }, // 围栏外
];

testPoints.forEach((point, index) => {
  const isInside = fence.isInside(point);
  const distance = fence.distanceToBoundary(point);
  console.log(`点${index + 1}: 在围栏内=${isInside}, 到边界距离=${distance.toFixed(2)}m`);
});
```

### 路径规划辅助

```typescript
class RouteAnalyzer {
  private spatial: SpatialGeometryImpl;

  constructor() {
    this.spatial = new SpatialGeometryImpl();
  }

  // 分析路径
  analyzeRoute(route: LineString) {
    const totalDistance = this.spatial.length(route, 'kilometers');
    const bounds = this.spatial.bounds(route);
    const segments = this.getSegments(route);

    let totalTurns = 0;
    let sharpTurns = 0;

    for (let i = 1; i < segments.length - 1; i++) {
      const angle = this.calculateTurnAngle(segments[i - 1], segments[i], segments[i + 1]);

      if (Math.abs(angle) > 15) {
        totalTurns++;
        if (Math.abs(angle) > 90) {
          sharpTurns++;
        }
      }
    }

    return {
      totalDistance: totalDistance.toFixed(2) + ' km',
      bounds,
      segmentCount: segments.length,
      totalTurns,
      sharpTurns,
      complexity: totalTurns / segments.length,
    };
  }

  // 检查路径与障碍物的交集
  checkObstacles(route: LineString, obstacles: Polygon[]): Polygon[] {
    return obstacles.filter((obstacle) => this.spatial.intersects(route, obstacle));
  }

  // 计算路径缓冲区
  createRouteCorridor(route: LineString, width: number): Polygon {
    return this.spatial.buffer(route, width / 2, 'meters') as Polygon;
  }

  private getSegments(route: LineString): [number, number][] {
    return route.coordinates as [number, number][];
  }

  private calculateTurnAngle(
    p1: [number, number],
    p2: [number, number],
    p3: [number, number],
  ): number {
    const bearing1 = GeometryUtils.bearing(p1, p2);
    const bearing2 = GeometryUtils.bearing(p2, p3);

    let angle = bearing2 - bearing1;
    if (angle > 180) angle -= 360;
    if (angle < -180) angle += 360;

    return angle;
  }
}

// 使用路径分析器
const routeAnalyzer = new RouteAnalyzer();
const analysis = routeAnalyzer.analyzeRoute(route);
console.log('路径分析:', analysis);

// 检查障碍物
const obstacles = [polygon1, polygon2];
const intersectingObstacles = routeAnalyzer.checkObstacles(route, obstacles);
console.log('路径经过的障碍物:', intersectingObstacles.length);
```

### 空间数据可视化准备

```typescript
// 为地图可视化准备数据
function prepareVisualizationData(geometries: any[]) {
  const features = geometries.map((geometry, index) => {
    const bounds = spatial.bounds(geometry);
    const center = spatial.center(geometry);

    let area = 0;
    let length = 0;

    if (geometry.type === 'Polygon' || geometry.type === 'MultiPolygon') {
      area = spatial.area(geometry, 'kilometers');
    }

    if (
      geometry.type === 'LineString' ||
      geometry.type === 'MultiLineString' ||
      geometry.type === 'Polygon' ||
      geometry.type === 'MultiPolygon'
    ) {
      length = spatial.length(geometry, 'kilometers');
    }

    return {
      id: index,
      geometry,
      properties: {
        bounds,
        center: center.coordinates,
        area: area > 0 ? parseFloat(area.toFixed(3)) : null,
        length: length > 0 ? parseFloat(length.toFixed(3)) : null,
      },
    };
  });

  // 计算整体边界框
  const allBounds = features.map((f) => f.properties.bounds);
  const overallBounds = [
    Math.min(...allBounds.map((b) => b[0])), // minX
    Math.min(...allBounds.map((b) => b[1])), // minY
    Math.max(...allBounds.map((b) => b[2])), // maxX
    Math.max(...allBounds.map((b) => b[3])), // maxY
  ];

  return {
    type: 'FeatureCollection',
    features,
    bbox: overallBounds,
  };
}

// 准备可视化数据
const visualData = prepareVisualizationData([beijing, route, polygon]);
console.log('可视化数据:', JSON.stringify(visualData, null, 2));
```

## 性能优化技巧

### 批量处理

```typescript
// 批量距离计算
function batchDistanceCalculation(points: Point[], center: Point): Map<string, number> {
  const results = new Map<string, number>();

  points.forEach((point, index) => {
    const distance = spatial.distance(center, point);
    results.set(`point_${index}`, distance);
  });

  return results;
}

// 批量包含检测
function batchContainmentCheck(testPoints: Point[], boundary: Polygon): boolean[] {
  return testPoints.map((point) => spatial.contains(boundary, point));
}
```

### 近似计算

```typescript
// 对于远距离，使用简化的距离计算
function approximateDistance(p1: Point, p2: Point): number {
  const [lon1, lat1] = p1.coordinates;
  const [lon2, lat2] = p2.coordinates;

  // 简化的球面距离公式（适用于短距离）
  const R = 6371000; // 地球半径（米）
  const dLat = GeometryUtils.toRadians(lat2 - lat1);
  const dLon = GeometryUtils.toRadians(lon2 - lon1);

  const a =
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(GeometryUtils.toRadians(lat1)) *
      Math.cos(GeometryUtils.toRadians(lat2)) *
      Math.sin(dLon / 2) *
      Math.sin(dLon / 2);

  return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}
```

通过这个详细的指南，你可以充分利用 SynapseDB 的空间几何计算功能，处理各种地理空间数据分析任务，构建强大的位置服务和 GIS 应用。
