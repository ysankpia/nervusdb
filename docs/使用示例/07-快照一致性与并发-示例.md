# 示例 07 · 快照一致性与并发

## 目标

- 展示 `withSnapshot`、读者注册与 auto-compact 的互动
- 演练并发读写场景，避免破坏快照

## 场景一：长链查询

```ts
const snapshotResult = await db.withSnapshot(async (snap) =>
  snap.find({ object: 'service:billing' }).followReverse('DEPLOYED_ON').follow('OWNS').all(),
);
```

- 在回调期间 manifest epoch 固定
- `readers.json` 中会记录一个活跃读者

## 场景二：治理尊重读者

```bash
nervusdb auto-compact demo.nervusdb --mode=incremental --auto-gc
```

- 如有活跃读者，会输出 `Skipping compaction due to 1 active readers`

## 场景三：并发写入

```ts
await Promise.all([writerA(), writerB()]);

async function writerA() {
  const db = await NervusDB.open('demo.nervusdb', { enableLock: true });
  db.beginBatch({ txId: 'batch-A', sessionId: 'writerA' });
  await db.addFact({ subject: 'user:alice', predicate: 'HAS_ROLE', object: 'role:admin' });
  db.commitBatch();
  await db.close();
}
```

- `enableLock: true` 避免两个写者同时操作

## 监控读者

```bash
nervusdb readers demo.nervusdb
```

输出示例：`readerId=0 pid=12345 epoch=128 startedAt=...`

## 常见问题

| 情况                  | 解决                                                    |
| --------------------- | ------------------------------------------------------- |
| auto-compact 一直跳过 | 检查是否存在未结束的 `withSnapshot`；优化查询或错峰治理 |
| 查询读到旧数据        | 使用 `withSnapshot`，并在治理结束后重新读取             |
| 锁冲突                | 正常表现，等待写者释放或拆分数据库                      |

## 延伸阅读

- [教程 04 · 事务、WAL 与幂等](../教学文档/教程-04-事务-WAL-幂等.md)
- [docs/使用示例/09-嵌入式脚本与自动化-示例.md](09-嵌入式脚本与自动化-示例.md)
