# SynapseDB v1.4.0 高级功能使用指南

## 概述

SynapseDB v1.4.0 引入了四大核心高级功能模块：

1. **全文搜索引擎** - 支持中英文分词、TF-IDF/BM25 评分的高性能全文检索
2. **图算法库** - 包含 PageRank、社区发现、中心性分析等丰富的图算法
3. **空间几何计算** - GeoJSON 兼容的地理空间数据处理和计算
4. **性能基准测试** - 完整的性能分析、回归检测和报告生成框架

本指南将通过实际示例展示这些功能的使用方法。

## 1. 全文搜索引擎

### 基础使用

```typescript
import { SynapseDB } from '@/synapseDb';
import { FullTextSearchFactory } from '@/fulltext/engine';

// 创建全文搜索引擎实例
const searchEngine = FullTextSearchFactory.createEngine();

// 创建搜索索引
await searchEngine.createIndex(
  'documents',
  FullTextSearchFactory.createDefaultConfig(['title', 'content']),
);

// 索引文档
await searchEngine.indexDocument('documents', {
  id: 'doc1',
  fields: new Map([
    ['title', '人工智能技术发展'],
    ['content', '人工智能正在改变我们的世界，机器学习和深度学习技术快速发展。'],
  ]),
  tokens: [],
  timestamp: new Date(),
});

// 执行搜索
const results = await searchEngine.search('documents', '人工智能', {
  maxResults: 10,
  scorer: 'bm25', // 使用 BM25 算法评分
});

console.log('搜索结果:', results);
```

### 高级搜索功能

```typescript
// 布尔查询
const booleanResults = await searchEngine.search('documents', '人工智能 AND 机器学习 NOT 深度学习');

// 模糊搜索
const fuzzyResults = await searchEngine.search('documents', '人工*能', {
  fuzzy: true,
  maxResults: 5,
});

// 短语搜索
const phraseResults = await searchEngine.search('documents', '"机器学习技术"', {
  phraseSearch: true,
});
```

### 集成到 SynapseDB

```typescript
import { SynapseDB } from '@/synapseDb';

const db = await SynapseDB.open('knowledge.synapsedb');

// 添加带搜索能力的事实
db.addFact(
  {
    subject: 'article:ai_development',
    predicate: 'hasContent',
    object: '人工智能技术正在快速发展',
  },
  {
    // 启用全文搜索索引
    enableFullTextSearch: true,
    searchFields: ['object'],
  },
);

// 通过全文搜索查询事实
const searchResults = db.searchFacts('人工智能', {
  fields: ['object'],
  maxResults: 10,
});
```

## 2. 图算法库

### PageRank 中心性分析

```typescript
import { MemoryGraph } from '@/algorithms/graph';
import { GraphAlgorithmSuiteImpl } from '@/algorithms/suite';

// 创建内存图
const graph = new MemoryGraph();

// 添加节点和边
const nodes = ['A', 'B', 'C', 'D', 'E'];
nodes.forEach((id) => {
  graph.addNode({ id, value: id });
});

// 添加有向边（表示链接关系）
const edges = [
  ['A', 'B'],
  ['A', 'C'],
  ['B', 'C'],
  ['C', 'A'],
  ['C', 'D'],
  ['D', 'C'],
  ['E', 'D'],
];

edges.forEach(([source, target]) => {
  graph.addEdge({
    source,
    target,
    type: 'link',
    weight: 1.0,
  });
});

// 创建算法套件
const algorithms = new GraphAlgorithmSuiteImpl(graph);

// 计算 PageRank
const pageRankResult = algorithms.centrality.pageRank({
  dampingFactor: 0.85,
  maxIterations: 100,
  tolerance: 1e-6,
});

console.log('PageRank 分数:', pageRankResult.scores);
console.log('收敛统计:', pageRankResult.stats);
```

### 社区发现算法

```typescript
// Louvain 社区发现
const communityResult = algorithms.community.louvain({
  resolution: 1.0,
  maxIterations: 100,
});

console.log('发现的社区数:', communityResult.communityCount);
console.log('模块度:', communityResult.modularity);
console.log('社区分配:', communityResult.communities);

// 标签传播算法
const labelPropResult = algorithms.community.labelPropagation({
  maxIterations: 50,
});

console.log('标签传播结果:', labelPropResult.labels);
```

### 最短路径算法

```typescript
// Dijkstra 最短路径
const shortestPaths = algorithms.path.dijkstra('A');
console.log('从 A 到其他节点的最短路径:', shortestPaths);

// A* 路径搜索（需要启发式函数）
const astarPath = algorithms.path.aStar('A', 'D', (node) => {
  // 简单的启发式函数
  return Math.abs(node.charCodeAt(0) - 'D'.charCodeAt(0));
});

console.log('A* 路径:', astarPath);
```

### 相似度计算

```typescript
// Jaccard 相似度
const jaccardSim = algorithms.similarity.jaccard('A', 'C');
console.log('Jaccard 相似度:', jaccardSim);

// 余弦相似度
const cosineSim = algorithms.similarity.cosine('A', 'C');
console.log('余弦相似度:', cosineSim);
```

## 3. 空间几何计算

### 基础几何操作

```typescript
import { SpatialGeometryImpl } from '@/spatial/geometry';

const spatial = new SpatialGeometryImpl();

// 定义地理坐标点
const beijing: Point = {
  type: 'Point',
  coordinates: [116.4074, 39.9042], // [经度, 纬度]
};

const shanghai: Point = {
  type: 'Point',
  coordinates: [121.4737, 31.2304],
};

// 计算两点间距离（米）
const distance = spatial.distance(beijing, shanghai);
console.log(`北京到上海距离: ${(distance / 1000).toFixed(2)}km`);

// 计算不同单位的距离
const distanceKm = spatial.distance(beijing, shanghai, 'kilometers');
console.log(`距离: ${distanceKm.toFixed(2)}km`);
```

### 多边形操作

```typescript
// 定义多边形区域
const polygon: Polygon = {
  type: 'Polygon',
  coordinates: [
    [
      [116.3, 39.8], // 西南角
      [116.5, 39.8], // 东南角
      [116.5, 40.0], // 东北角
      [116.3, 40.0], // 西北角
      [116.3, 39.8], // 闭合
    ],
  ],
};

// 计算多边形面积
const area = spatial.area(polygon, 'kilometers');
console.log(`区域面积: ${area.toFixed(2)}平方公里`);

// 计算边界框
const bounds = spatial.bounds(polygon);
console.log('边界框:', bounds); // [minX, minY, maxX, maxY]

// 检查点是否在多边形内
const isInside = spatial.contains(polygon, beijing);
console.log('北京是否在区域内:', isInside);
```

### 几何关系分析

```typescript
// 创建另一个多边形
const polygon2: Polygon = {
  type: 'Polygon',
  coordinates: [
    [
      [116.4, 39.9],
      [116.6, 39.9],
      [116.6, 40.1],
      [116.4, 40.1],
      [116.4, 39.9],
    ],
  ],
};

// 检查两个多边形是否相交
const intersects = spatial.intersects(polygon, polygon2);
console.log('两个区域是否相交:', intersects);

// 计算交集
const intersection = spatial.intersection(polygon, polygon2);
if (intersection) {
  console.log('交集区域:', intersection);
}

// 计算并集
const union = spatial.union(polygon, polygon2);
console.log('并集区域:', union);
```

### 缓冲区和简化

```typescript
// 创建缓冲区（扩展区域）
const buffered = spatial.buffer(beijing, 1000, 'meters'); // 1km 缓冲区
console.log('1km 缓冲区:', buffered);

// 几何简化（减少顶点数量）
const simplified = spatial.simplify(polygon, 0.01);
console.log('简化后的多边形:', simplified);
```

## 4. 性能基准测试

### 使用命令行工具

```bash
# 运行完整基准测试
pnpm benchmark

# 运行特定模块测试
pnpm benchmark:core      # 核心功能测试
pnpm benchmark:search    # 全文搜索测试
pnpm benchmark:graph     # 图算法测试
pnpm benchmark:spatial   # 空间计算测试

# 生成多种格式报告
pnpm benchmark -- --format html,json,csv --output ./reports

# 性能回归检测
pnpm benchmark -- regression --baseline ./reports/baseline.json --threshold 15
```

### 编程接口使用

```typescript
import { BenchmarkManager, runBenchmark, synapseDBCoreSuite } from '@/benchmark';

// 创建基准测试管理器
const benchmarkManager = new BenchmarkManager();

// 运行特定测试套件
const results = await benchmarkManager.runSuite(synapseDBCoreSuite);

// 生成控制台报告
const consoleReport = benchmarkManager.generateConsoleReport({
  timestamp: new Date(),
  environment: {
    /* 环境信息 */
  },
  results,
  summary: {
    /* 摘要统计 */
  },
});

console.log(consoleReport);
```

### 自定义基准测试

```typescript
import { BenchmarkTest, BenchmarkSuite } from '@/benchmark/types';

// 定义自定义测试
const customTest: BenchmarkTest = {
  name: '自定义数据库操作',
  description: '测试特定业务场景性能',
  test: async (config) => {
    const startTime = performance.now();

    // 执行你的测试代码
    const db = await SynapseDB.open(':memory:');

    for (let i = 0; i < 1000; i++) {
      db.addFact({
        subject: `entity_${i}`,
        predicate: 'hasProperty',
        object: `value_${i}`,
      });
    }

    await db.flush();
    const executionTime = performance.now() - startTime;

    return {
      name: '自定义数据库操作',
      description: '测试特定业务场景性能',
      executionTime,
      memoryUsage: process.memoryUsage().heapUsed,
      operations: 1000,
      operationsPerSecond: (1000 / executionTime) * 1000,
      averageLatency: executionTime / 1000,
      minLatency: 0,
      maxLatency: 0,
      p95Latency: 0,
      p99Latency: 0,
      dataSize: 1000,
      timestamp: new Date(),
    };
  },
};

// 创建测试套件
const customSuite: BenchmarkSuite = {
  name: '自定义测试套件',
  description: '针对特定场景的性能测试',
  benchmarks: [customTest],
  config: {
    warmupRuns: 2,
    runs: 3,
    timeout: 30000,
  },
};

// 运行自定义测试
const customResults = await benchmarkManager.runSuite(customSuite);
```

## 综合示例：知识图谱应用

结合所有功能构建一个完整的知识图谱应用：

```typescript
import { SynapseDB } from '@/synapseDb';
import { FullTextSearchFactory } from '@/fulltext/engine';
import { MemoryGraph } from '@/algorithms/graph';
import { GraphAlgorithmSuiteImpl } from '@/algorithms/suite';
import { SpatialGeometryImpl } from '@/spatial/geometry';

class KnowledgeGraph {
  private db: SynapseDB;
  private searchEngine: any;
  private graph: MemoryGraph;
  private algorithms: GraphAlgorithmSuiteImpl;
  private spatial: SpatialGeometryImpl;

  async initialize() {
    // 初始化数据库
    this.db = await SynapseDB.open('knowledge_graph.synapsedb');

    // 初始化搜索引擎
    this.searchEngine = FullTextSearchFactory.createEngine();
    await this.searchEngine.createIndex(
      'entities',
      FullTextSearchFactory.createDefaultConfig(['name', 'description']),
    );

    // 初始化图算法
    this.graph = new MemoryGraph();
    this.algorithms = new GraphAlgorithmSuiteImpl(this.graph);

    // 初始化空间计算
    this.spatial = new SpatialGeometryImpl();
  }

  // 添加实体
  async addEntity(id: string, name: string, description: string, location?: [number, number]) {
    // 存储到数据库
    this.db.addFact({
      subject: id,
      predicate: 'hasName',
      object: name,
    });

    this.db.addFact({
      subject: id,
      predicate: 'hasDescription',
      object: description,
    });

    if (location) {
      this.db.addFact({
        subject: id,
        predicate: 'hasLocation',
        object: JSON.stringify(location),
      });
    }

    // 添加到全文搜索索引
    await this.searchEngine.indexDocument('entities', {
      id,
      fields: new Map([
        ['name', name],
        ['description', description],
      ]),
      tokens: [],
      timestamp: new Date(),
    });

    // 添加到图结构
    this.graph.addNode({ id, value: { name, description, location } });
  }

  // 添加关系
  addRelationship(fromId: string, relationshipType: string, toId: string, weight: number = 1.0) {
    // 存储关系到数据库
    this.db.addFact({
      subject: fromId,
      predicate: relationshipType,
      object: toId,
    });

    // 添加到图结构
    this.graph.addEdge({
      source: fromId,
      target: toId,
      type: relationshipType,
      weight,
    });
  }

  // 智能搜索（结合全文搜索和图算法）
  async intelligentSearch(query: string) {
    // 1. 全文搜索找到相关实体
    const searchResults = await this.searchEngine.search('entities', query, {
      maxResults: 20,
    });

    // 2. 获取相关实体的 PageRank 分数
    const pageRankResults = this.algorithms.centrality.pageRank();

    // 3. 结合相关性和重要性排序
    const rankedResults = searchResults
      .map((result) => ({
        ...result,
        importance: pageRankResults.scores.get(result.documentId) || 0,
        combinedScore: result.score * (1 + (pageRankResults.scores.get(result.documentId) || 0)),
      }))
      .sort((a, b) => b.combinedScore - a.combinedScore);

    return rankedResults;
  }

  // 发现相关实体
  findRelatedEntities(entityId: string, maxDistance: number = 2) {
    // 使用图算法找到指定距离内的相关实体
    const shortestPaths = this.algorithms.path.dijkstra(entityId);

    return Object.entries(shortestPaths)
      .filter(([_, distance]) => distance <= maxDistance && distance > 0)
      .map(([nodeId, distance]) => ({
        entityId: nodeId,
        distance,
        entity: this.graph.getNode(nodeId),
      }))
      .sort((a, b) => a.distance - b.distance);
  }

  // 地理位置相关查询
  findNearbyEntities(centerLocation: [number, number], radiusKm: number) {
    const centerPoint = {
      type: 'Point' as const,
      coordinates: centerLocation,
    };

    const nearbyEntities = [];

    // 遍历所有有位置信息的实体
    for (const [nodeId, node] of this.graph.getNodes()) {
      if (node.value.location) {
        const entityPoint = {
          type: 'Point' as const,
          coordinates: node.value.location,
        };

        const distance = this.spatial.distance(centerPoint, entityPoint, 'kilometers');

        if (distance <= radiusKm) {
          nearbyEntities.push({
            entityId: nodeId,
            entity: node.value,
            distance,
          });
        }
      }
    }

    return nearbyEntities.sort((a, b) => a.distance - b.distance);
  }

  // 社区发现
  findCommunities() {
    return this.algorithms.community.louvain({
      resolution: 1.0,
      maxIterations: 100,
    });
  }

  // 性能分析
  async analyzePerformance() {
    const { runBenchmark } = await import('@/benchmark');

    return await runBenchmark({
      outputFormats: ['console', 'json'],
    });
  }
}

// 使用示例
async function demonstrateKnowledgeGraph() {
  const kg = new KnowledgeGraph();
  await kg.initialize();

  // 添加实体
  await kg.addEntity('beijing', '北京', '中国首都', [116.4074, 39.9042]);
  await kg.addEntity('shanghai', '上海', '中国经济中心', [121.4737, 31.2304]);
  await kg.addEntity('tsinghua', '清华大学', '顶尖学府', [116.3261, 40.0031]);

  // 添加关系
  kg.addRelationship('tsinghua', 'locatedIn', 'beijing', 1.0);
  kg.addRelationship('beijing', 'connectedTo', 'shanghai', 0.8);

  // 智能搜索
  const searchResults = await kg.intelligentSearch('大学');
  console.log('搜索结果:', searchResults);

  // 发现相关实体
  const related = kg.findRelatedEntities('beijing', 2);
  console.log('北京相关实体:', related);

  // 地理位置查询
  const nearby = kg.findNearbyEntities([116.4074, 39.9042], 50);
  console.log('北京附近50公里内的实体:', nearby);

  // 社区发现
  const communities = kg.findCommunities();
  console.log('发现的社区:', communities);

  // 性能分析
  const performance = await kg.analyzePerformance();
  console.log('性能分析结果已生成');
}

// 运行演示
demonstrateKnowledgeGraph().catch(console.error);
```

## 总结

SynapseDB v1.4.0 的四大核心功能模块为构建复杂的知识管理和数据分析应用提供了强大的基础：

1. **全文搜索** - 提供智能的文本检索和相关性排序
2. **图算法** - 支持复杂的关系分析和网络计算
3. **空间计算** - 处理地理空间数据和位置相关查询
4. **性能测试** - 确保应用在各种负载下的稳定性能

通过组合使用这些功能，你可以构建出功能丰富、性能卓越的现代数据应用。

## 参考资料

- [SynapseDB 设计文档](../SynapseDB设计文档.md)
- [全文搜索 API 文档](./全文搜索使用指南.md)
- [图算法库 API 文档](./图算法库使用指南.md)
- [空间几何 API 文档](./空间几何计算指南.md)
- [性能基准测试指南](./性能基准测试指南.md)
