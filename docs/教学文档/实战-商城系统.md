# 实战 · 商城系统（从建模到查询与推荐）

本实战以“电商/商城”场景为例，展示如何用 SynapseDB 建模用户、商品、类目、订单及交互行为，并完成常见查询、推荐、运维与幂等写入。

适合读者：后端/数据工程师，准备以轻量嵌入式图谱替代/补充关系模型的一些联想型查询与分析。

---

## 1. 数据建模（SPO 三元组）

实体（主语/宾语，统一字符串命名）：
- 用户：`user:<uid>`（如 `user:1001`）
- 商品：`product:<sku>`（如 `product:SKU-iphone15`）
- 类目：`category:<name>`（如 `category:手机`）
- 订单：`order:<oid>`（如 `order:2025-0001`）

关系（谓词）：
- `BELONGS_TO`：商品 → 类目
- `ORDERED`：用户 → 订单
- `CONTAINS`：订单 → 商品
- `VIEWED`：用户 → 商品（浏览）
- `RATED`：用户 → 商品（评分）
- `SIMILAR`：商品 ↔ 商品（相似/同类/共购）
- 派生边（可选）：`PURCHASED`：用户 → 商品（从订单 CONTAINS 聚合得到）

属性建议：
- 节点属性：
  - 商品：`{ title, price, stock, brand, attrs... }`
  - 订单：`{ createdAt, total, status }`
  - 用户：`{ vipLevel, region }`
- 边属性：
  - `CONTAINS`：`{ quantity, unitPrice }`
  - `RATED`：`{ rating, ts }`

---

## 2. 初始化与导入脚本

```ts
// scripts/bootstrap-commerce.mts
import { SynapseDB } from 'synapsedb';

const db = await SynapseDB.open('commerce.synapsedb', {
  pageSize: 1024,
  enableLock: true,
  registerReader: true,
});

// 类目
const categories = ['手机', '配件'];
for (const name of categories) db.addFact({ subject: `category:${name}`, predicate: 'TYPE', object: 'Category' });

// 商品
const products = [
  { sku: 'SKU-iphone15', title: 'iPhone 15', price: 5999, stock: 100, cat: '手机' },
  { sku: 'SKU-airpods3', title: 'AirPods 3', price: 1299, stock: 200, cat: '配件' },
];
for (const p of products) {
  const rec = db.addFact({ subject: `product:${p.sku}`, predicate: 'BELONGS_TO', object: `category:${p.cat}` });
  db.setNodeProperties(rec.subjectId, { title: p.title, price: p.price, stock: p.stock, brand: 'Apple' });
}

// 用户与浏览/评分行为
const user = 'user:1001';
db.addFact({ subject: user, predicate: 'TYPE', object: 'User' });
db.addFact({ subject: user, predicate: 'VIEWED', object: 'product:SKU-iphone15' });
db.addFact({ subject: user, predicate: 'RATED', object: 'product:SKU-iphone15' });
{
  const k = {
    subjectId: db.getNodeId(user)!,
    predicateId: db.getNodeId('RATED')!,
    objectId: db.getNodeId('product:SKU-iphone15')!,
  };
  db.setEdgeProperties(k, { rating: 5, ts: Date.now() });
}

// 订单与订单行（CONTAINS 边上记录数量与单价；订单上记录金额/状态）
const orderId = 'order:2025-0001';
db.addFact({ subject: user, predicate: 'ORDERED', object: orderId });
db.addFact({ subject: orderId, predicate: 'CONTAINS', object: 'product:SKU-iphone15' });
{
  const k = {
    subjectId: db.getNodeId(orderId)!,
    predicateId: db.getNodeId('CONTAINS')!,
    objectId: db.getNodeId('product:SKU-iphone15')!,
  };
  db.setEdgeProperties(k, { quantity: 1, unitPrice: 5999 });
}
// 订单属性
const orderNodeId = db.getNodeId(orderId)!;
db.setNodeProperties(orderNodeId, { createdAt: Date.now(), total: 5999, status: 'PAID' });

await db.flush();
await db.close();
console.log('Commerce bootstrap done.');
```

运行：

```bash
node --loader ts-node/esm scripts/bootstrap-commerce.mts   # 或 tsx scripts/bootstrap-commerce.mts
```

---

## 3. 常见查询

- 某类目下的商品：
```ts
// category:手机 → 哪些 product
const res = db.find({ object: 'category:手机', predicate: 'BELONGS_TO' }).followReverse('BELONGS_TO').all();
// 或直接：db.find({ predicate: 'BELONGS_TO', object: 'category:手机' }).all()
```

- 用户的所有订单 → 商品明细：
```ts
const items = db
  .find({ subject: 'user:1001', predicate: 'ORDERED' }) // user → order
  .follow('CONTAINS')                                    // order → product
  .all();
```

- 用户购买历史（派生 PURCHASED）：
```ts
const purchased = db
  .find({ subject: 'user:1001', predicate: 'ORDERED' })
  .follow('CONTAINS')
  .all()
  .map(x => ({ user: x.subject, product: x.object }));
```

- 类目 Top-N 商品（基于 CONTAINS 计数）：
```ts
// 简单版：在应用层分组聚合
const byCat = db.find({ predicate: 'BELONGS_TO', object: 'category:手机' }).all();
const skuSet = new Set(byCat.map(x => x.subject));
const counts = new Map<string, number>();
for (const sku of skuSet) {
  const times = db.find({ object: sku, predicate: 'CONTAINS' }).all().length;
  counts.set(sku, times);
}
const top = [...counts.entries()].sort((a,b)=>b[1]-a[1]).slice(0,5);
```

- 相似/共购推荐（与某商品同单出现次数最多）：
```ts
const seed = 'product:SKU-iphone15';
const co = new Map<string, number>();
// 同单：seed <-CONTAINS- order -CONTAINS-> other
for (const o of db.find({ object: seed, predicate: 'CONTAINS' }).all()) {
  for (const p of db.find({ subject: o.subject, predicate: 'CONTAINS' }).all()) {
    if (p.object === seed) continue;
    co.set(p.object, (co.get(p.object) ?? 0) + 1);
  }
}
const recs = [...co.entries()].sort((a,b)=>b[1]-a[1]).slice(0,5);
```

---

## 4. 下单流程（写入、库存更新、幂等）

```ts
async function placeOrder(db: SynapseDB, userId: string, lines: Array<{ sku: string; qty: number }>, oid: string) {
  const txId = `ORDER-${oid}`; // 幂等：以订单号作为 txId
  db.beginBatch({ txId, sessionId: userId });
  try {
    const orderNode = `order:${oid}`;
    db.addFact({ subject: userId, predicate: 'ORDERED', object: orderNode });
    let total = 0;
    for (const { sku, qty } of lines) {
      const prod = `product:${sku}`;
      db.addFact({ subject: orderNode, predicate: 'CONTAINS', object: prod });
      const prodId = db.getNodeId(prod)!;
      const price = (db.getNodeProperties(prodId)?.price as number) ?? 0;
      total += price * qty;
      const k = { subjectId: db.getNodeId(orderNode)!, predicateId: db.getNodeId('CONTAINS')!, objectId: prodId };
      db.setEdgeProperties(k, { quantity: qty, unitPrice: price });
      // 扣减库存
      const props = db.getNodeProperties(prodId) ?? {};
      props.stock = Math.max(0, (props.stock as number) - qty);
      db.setNodeProperties(prodId, props);
    }
    db.setNodeProperties(db.getNodeId(orderNode)!, { createdAt: Date.now(), total, status: 'PAID' });
    db.commitBatch({ durable: true });
  } catch (e) {
    db.abortBatch();
    throw e;
  }
}
```

要点：
- 使用 `txId = 订单号` 提供跨周期幂等；重试不会重复下单
- `durable: true` 保证提交立即落盘

---

## 5. 数据服务 API（片段）

- 获取用户最近订单：`find({ subject:user, predicate:'ORDERED' })` + 属性读取
- 商品搜索/筛选：根据属性（价格/品牌）与关系（类目）组合过滤
- 推荐/相似：共购、浏览后购买（VIEWED → ORDERED/CONTAINS）

> 后端可封装查询组合，或提供通用 DSL → SynapseDB 查询的转换层。

---

## 6. 运维与治理

- 概况：`synapsedb stats commerce.synapsedb`
- 自动合并：
```bash
synapsedb auto-compact commerce.synapsedb \
  --mode=incremental --orders=SPO --min-merge=2 --hot-threshold=1 --max-primary=1 --auto-gc
```
- GC：`synapsedb gc commerce.synapsedb`
- 自检/修复：`synapsedb check --strict` / `synapsedb repair --fast`

---

## 7. 性能与扩展建议

- 将高频维度（类目/品牌）建成事实关系，低频属性放到节点属性
- 大报表/TopN 在应用层聚合（或周期性离线写回属性，形成“物化属性”）
- 合并策略：日常增量、定期 rewrite；热点门店/品类可单独治理
- 以 `withSnapshot` 包裹长链路查询，避免治理并发影响

---

## 8. 数据导出与对接

- 导出订单子图用于 BI/可视化（见“代码知识图谱实战”的导出脚本示例）
- 或把“共购/相似”离线计算为 `SIMILAR` 边，供在线快速检索

---

至此，你已完成商城系统的从建模、下单、查询、推荐到治理的端到端实践。根据你的业务规模，可进一步把某些聚合结果写回属性或派生边，形成“读优化”的混合图模型。

