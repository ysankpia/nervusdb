# 实战 · 商城系统

## 场景

构建一个电商订单知识库，追踪用户、订单、商品、库存、物流之间的关系，为风控与客服提供实时联想查询。

## 数据模型

| 主体         | 谓词           | 客体                      | 属性                  |
| ------------ | -------------- | ------------------------- | --------------------- |
| `user:<id>`  | `PLACED_ORDER` | `order:<id>`              | `{ channel, total }`  |
| `order:<id>` | `CONTAINS`     | `sku:<id>`                | `{ quantity, price }` |
| `order:<id>` | `FULFILLED_BY` | `warehouse:<id>`          | `{ eta }`             |
| `sku:<id>`   | `BELONGS_TO`   | `category:<id>`           | `{}`                  |
| `order:<id>` | `STATUS`       | `status:Paid/Shipped/...` | `{ updatedAt }`       |

## 导入流程

```ts
import { NervusDB } from 'nervusdb';
import { loadOrders } from './etl';

const db = await NervusDB.open('commerce.nervusdb', {
  enableLock: true,
  enablePersistentTxDedupe: true,
});

for await (const { txId, facts } of loadOrders()) {
  db.beginBatch({ txId, sessionId: 'order-etl' });
  for (const fact of facts) {
    await db.addFact(fact.entity, fact.props);
  }
  db.commitBatch();
}

await db.flush();
```

## 查询示例

1. **订单上下文**

```ts
const context = await db
  .find({ subject: 'order:2025-0001' })
  .follow('CONTAINS')
  .followReverse('PLACED_ORDER')
  .follow('STATUS')
  .all();
```

2. **风险用户识别**

```ts
const risky = await db
  .aggregate()
  .match({ predicate: 'PLACED_ORDER' })
  .groupBy(['subject'])
  .sum('totalAmount', (edge) => edge.edgeProperties?.total as number)
  .count('orderCount')
  .having((g) => g.sum('totalAmount') > 50000 || g.count('orderCount') > 100)
  .execute();
```

3. **物流延迟通知**

```ts
const delayed = await db
  .find({ predicate: 'FULFILLED_BY' })
  .where((edge) => new Date(edge.edgeProperties?.eta!).getTime() < Date.now())
  .followReverse('STATUS')
  .all();
```

## 运维流程

- 每日执行 `nervusdb auto-compact commerce.nervusdb --hot-threshold=1.2 --auto-gc`
- 使用 `nervusdb stats --txids` 监控订单写入速率
- 定时导出 `nervusdb dump` 数据供下游数据仓库消费

## 与业务系统集成

- 服务端 GraphQL：将订单查询映射为 GraphQL resolver
- 风控策略：在规则引擎中调用 QueryBuilder 结果
- 报表：通过 `aggregate()` 输出指标，结合 BI 工具展示

## FAQ

| 问题               | 建议                                             |
| ------------------ | ------------------------------------------------ |
| 流量高峰写入压力大 | 使用批次、拆分数据库、启用 LSM-Lite              |
| 查询结果过大       | Streaming 输出并分页处理                         |
| 物流状态不同步     | 定期对外部系统执行增量同步，利用 `txId` 保证幂等 |

## 延伸阅读

- [docs/使用示例/04-事务与幂等-示例.md](../使用示例/04-事务与幂等-示例.md)
- [docs/使用示例/06-流式查询与大结果-示例.md](../使用示例/06-流式查询与大结果-示例.md)
- [docs/使用示例/01-项目接入-本地tgz安装.md](../使用示例/01-项目接入-本地tgz安装.md)
