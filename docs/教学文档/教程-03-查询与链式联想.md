# 教程 03 · 查询与链式联想

## 目标

- 掌握 QueryBuilder 的链式查询、anchor 与 Streaming 能力
- 了解属性过滤、聚合与变长路径的使用方式
- 熟悉 withSnapshot 对读一致性的保障

## 前置要求

- 完成 [教程 02 · 数据模型与基础 CRUD](教程-02-数据模型与基础CRUD.md)
- 数据库中已存在 `FRIEND_OF`、`WORKS_AT` 等关系

## QueryBuilder 快速回顾

```ts
const chain = await db
  .find({ subject: 'user:alice', predicate: 'FRIEND_OF' })
  .follow('FRIEND_OF')
  .limit(3)
  .all();
```

- `find(criteria, options)`：按任意 subject/predicate/object 起步
- `follow(predicate)`：顺向扩展
- `followReverse(predicate)`：反向扩展
- `limit(n)` / `distinct()` / `takeUntil(fn)`：控制结果
- `where(filter)`：对节点/边属性进行过滤

## 锚点 (anchor)

```ts
await db.find({ object: 'user:carol' }, { anchor: 'subject' }).followReverse('FRIEND_OF').all();
```

- `anchor: 'subject'`：从主体 ID 构建前沿
- `anchor: 'object'`：从客体 ID 构建前沿
- `anchor: 'both'`（默认）：同时采集 subject/object，适合链式跳转

## 属性过滤与 Streaming（建议使用结构化过滤）

```ts
for await (const batch of db
  .findLazy({ predicate: 'FRIEND_OF' })
  .whereProperty('strength', '>=', 0.7, 'edge')
  .batch(100)) {
  console.log(batch.length);
}
```

- Streaming 模式按批次返回，可处理大规模结果
- `batchSize` 默认 256，可按内存调优

## 聚合查询

```ts
const groups = await db
  .aggregate()
  .match({ predicate: 'FRIEND_OF' })
  .groupBy(['subject'])
  .count('friendCount')
  .avg('avgStrength', (edge) => edge.edgeProperties?.strength as number)
  .execute();
```

- 支持 `count`、`sum`、`avg`、`min`、`max`、`groupBy`
- 聚合期间会自动固定快照

## 变长路径

```ts
const shortest = await db
  .find({ subject: 'user:alice', predicate: 'FRIEND_OF' })
  .variablePath('FRIEND_OF', { min: 1, max: 4 })
  .shortest(userIdEve);
```

- `variable()` 定义变长路径
- `shortestPath()` / `allPaths()` 提供最短或所有路径
- 支持权重字段与 A\*、双向 BFS（详见 `docs/使用示例/路径与最短路径.md`）

## 读快照一致性

```ts
const consistent = await db.withSnapshot(async (snap) =>
  snap.find({ object: 'service:api' }).followReverse('DEPLOYED_ON').follow('OWNS').all(),
);
```

- 回调内 manifest epoch 固定，后台 compaction/GC 不影响结果
- QueryBuilder 单次执行也会在内部 pin epoch

## 常见模式

| 需求     | 写法                                      |
| -------- | ----------------------------------------- |
| 正向多跳 | `find()` → `follow()` × N                 |
| 反向溯源 | `find()` → `followReverse()`              |
| 条件过滤 | `where()` / `whereNode()` / `whereEdge()` |
| 去重     | `distinct()` 或在聚合中使用 `groupBy`     |
| 限制     | `limit()` / `takeUntil()`                 |
| 流式分析 | `stream()` / `streamFacts()`              |

## 验证练习

1. 找出 Alice 的三度好友，过滤掉边权重 < 0.6
2. 统计每个团队的成员数量，按人数排序
3. 查询某个服务部署在多少集群上，并给出最短路径

## 常见问题

| 现象           | 分析                           | 处理                                    |
| -------------- | ------------------------------ | --------------------------------------- |
| 结果重复       | 未使用 `distinct` 或路径存在环 | 使用 `distinct` 或 `takeUntil` 防止循环 |
| 性能慢         | 过滤条件无法下推、缺少属性索引 | 建立属性索引或提前过滤节点              |
| where(predicate) 慢 | 在内存中过滤大结果集           | 使用 `whereProperty`/`whereLabel`/`followWithNodeProperty` |

> 注：如需让默认 `find()` 返回惰性链，可设置 `SYNAPSEDB_LAZY_QUERY=1`。默认关闭，避免破坏用户空间。
| Streaming 阻塞 | 批次过大或下游处理慢           | 减小 `batchSize` 或异步处理             |

## 延伸阅读

- [docs/使用示例/03-查询与联想-示例.md](../使用示例/03-查询与联想-示例.md)
- [docs/使用示例/流式查询使用教程.md](../使用示例/流式查询使用教程.md)
- [docs/使用示例/路径与最短路径.md](../使用示例/路径与最短路径.md)
