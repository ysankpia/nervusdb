# 教程 03 · 查询与链式联想

## 基本查询

```ts
// 任意组合：subject / predicate / object
db.find({ predicate: 'knows' }).all();
db.find({ subject: 'Alice', predicate: 'knows' }).all();
db.find({ object: 'Bob' }).all();
```

内部会根据已提供键选择最佳顺序（如 s+p → SPO）。

## 链式联想（QueryBuilder）

```ts
// Alice 的朋友的朋友
const res = db
  .find({ subject: 'Alice', predicate: 'knows' })
  .follow('knows')
  .follow('knows')
  .all();

// 反向联想：谁认识 Bob
const who = db.find({ object: 'Bob' }).followReverse('knows').all();

// 过滤与限制
const top2 = db
  .find({ predicate: 'knows' })
  .where((edge) => (edge.edgeProperties?.weight as number) > 10)
  .limit(2)
  .all();
```

## 锚点（anchor）与前沿

`anchor: 'subject' | 'object' | 'both'` 控制联想初始前沿选择：

- s+o → both；s → subject；p+o → subject；仅 o → object（默认从 object 启动反向更自然）

```ts
db.find({ object: 'Bob' }, { anchor: 'subject' }).followReverse('knows').all();
```

## 读快照一致性

长链路查询可使用 `withSnapshot(fn)` 固定 manifest epoch，避免后台合并/GC 造成视图漂移：

```ts
const results = await db.withSnapshot(async (snap) => {
  return snap
    .find({ object: 'Target' })
    .followReverse('HAS_METHOD')
    .followReverse('DEFINES')
    .all();
});
```

链式查询本身也会在执行期间暂时 pin epoch，确保单条链路稳定。

