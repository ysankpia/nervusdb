# 实战 · 构建代码知识图谱（从导入到查询与运维）

本实战将带你从 0 开始，基于一个小型代码仓库，构建“文件 → 类 → 方法 → 调用关系”的知识图谱，并完成查询、图谱导出与运维治理。

适合读者：熟悉 Node.js/TypeScript 的工程师，准备在工程或研发效能场景落地 SynapseDB。

---

## 1. 场景与数据建模

我们以三元组（S, P, O）描述代码元素及其关系，采用统一命名约定：

- 文件：`file:/path/to/file.ts`
- 类：`class:User`
- 方法：`method:User#login`

关系（谓词 P）：

- `DEFINES`：文件定义类或类定义方法
- `HAS_METHOD`：类拥有方法（可与 `DEFINES` 互换使用，依据团队喜好）
- `CALLS`：方法调用方法
- `IMPORTS`：文件导入文件

示例事实：

- `(file:/src/user.ts, DEFINES, class:User)`
- `(class:User, HAS_METHOD, method:User#login)`
- `(method:User#login, CALLS, method:Auth#issueToken)`

---

## 2. 初始化数据库

```ts
// scripts/bootstrap-graph.mts
import { SynapseDB } from 'synapsedb';

const db = await SynapseDB.open('codegraph.synapsedb', {
  pageSize: 1024,
  enableLock: true,
  registerReader: true,
});

// 基础样例：文件/类/方法/调用
const facts = [
  { s: 'file:/src/user.ts', p: 'DEFINES', o: 'class:User' },
  { s: 'class:User', p: 'HAS_METHOD', o: 'method:User#login' },
  { s: 'class:User', p: 'HAS_METHOD', o: 'method:User#logout' },
  { s: 'file:/src/auth.ts', p: 'DEFINES', o: 'class:Auth' },
  { s: 'class:Auth', p: 'HAS_METHOD', o: 'method:Auth#issueToken' },
  { s: 'method:User#login', p: 'CALLS', o: 'method:Auth#issueToken' },
  { s: 'file:/src/user.ts', p: 'IMPORTS', o: 'file:/src/auth.ts' },
];

for (const { s, p, o } of facts) {
  db.addFact({ subject: s, predicate: p, object: o });
}

await db.flush();
await db.close();
console.log('Bootstrap completed.');
```

运行：

```bash
node --loader ts-node/esm scripts/bootstrap-graph.mts   # 或 tsx scripts/bootstrap-graph.mts
```

> 也可直接在你的工程内调用 `SynapseDB` 完成初始化。

---

## 3. 基础查询（CRUD）

新增：见第 2 节；删除：

```ts
db.deleteFact({ subject: 'class:User', predicate: 'HAS_METHOD', object: 'method:User#logout' });
await db.flush();
```

点查与联想：

```ts
// 登录方法直接或间接调用的所有方法（两跳）
const called = db.find({ subject: 'method:User#login', predicate: 'CALLS' }).follow('CALLS').all();

// 反向联想：谁调用了 issueToken？
const callers = db.find({ object: 'method:Auth#issueToken' }).followReverse('CALLS').all();
```

属性更新（版本自增 `__v`）：

```ts
// 为方法与边增加属性
const idLogin = db.getNodeId('method:User#login')!;
db.setNodeProperties(idLogin, { complexity: 7, lastTouchedBy: 'ci-linter' });

const edgeKey = {
  subjectId: db.getNodeId('method:User#login')!,
  predicateId: db.getNodeId('CALLS')!,
  objectId: db.getNodeId('method:Auth#issueToken')!,
};
db.setEdgeProperties(edgeKey, { weight: 3 });
await db.flush();
```

> 修改 S/P/O 本身建议“删后加”并放入批次，保证语义清晰与原子性。

---

## 4. 事务与幂等（写入管线）

```ts
// 批量导入（带 txId，幂等可选）
db.beginBatch({ txId: 'IMPORT-2025-001', sessionId: 'ingest-worker-1' });
for (const row of bigList) {
  db.addFact({ subject: row.s, predicate: row.p, object: row.o });
}
db.commitBatch({ durable: true });
```

- 重放或崩溃恢复时，同一 `txId` 的重复提交将被忽略（若启用持久幂等）
- 关键写入建议 `durable: true` 获取更强持久性保障

---

## 5. 图谱导出（对接可视化）

将查询结果导出为 Cytoscape.js 可直接消费的 JSON：

```ts
// scripts/export-cyto.mts
import { SynapseDB } from 'synapsedb';
import { writeFile } from 'node:fs/promises';

const db = await SynapseDB.open('codegraph.synapsedb');

// 以某个种子方法为中心，2 步邻域子图
const seed = 'method:User#login';
const steps = 2;

const nodes = new Map<number, { data: { id: string; label: string } }>();
const edges: Array<{ data: { id: string; source: string; target: string; label: string } }> = [];

function ensureNode(id: number, label: string) {
  if (!nodes.has(id)) nodes.set(id, { data: { id: String(id), label } });
}

function addEdge(s: number, pLabel: string, o: number) {
  edges.push({
    data: { id: `${s}-${pLabel}-${o}`, source: String(s), target: String(o), label: pLabel },
  });
}

// 简化策略：以 follow/followReverse 构建邻域
let frontier = db.find({ subject: seed }).all();
for (let i = 0; i < steps; i += 1) {
  const next: typeof frontier = [] as any;
  for (const r of frontier) {
    const fwd = db.find({ subject: r.object }).all();
    for (const x of fwd) {
      ensureNode(r.subjectId, r.subject);
      ensureNode(x.objectId, x.object);
      addEdge(r.subjectId, r.predicate, x.objectId);
      (next as any).push(x);
    }
  }
  frontier = next as any;
}

const cy = { elements: { nodes: [...nodes.values()], edges } };
await writeFile('graph-cyto.json', JSON.stringify(cy, null, 2), 'utf8');
await db.close();
console.log('Exported to graph-cyto.json');
```

> 真实项目可根据需要合并同名/同义节点、补充属性、或限制边数以保证前端渲染性能。

---

## 6. 运维与治理

- 总览：`synapsedb stats codegraph.synapsedb`
- 自动合并（增量）：

```bash
synapsedb auto-compact codegraph.synapsedb \
  --mode=incremental --orders=SPO --min-merge=2 --hot-threshold=1 --max-primary=1 --auto-gc
```

- GC：`synapsedb gc codegraph.synapsedb`
- 自检/修复：`synapsedb check codegraph.synapsedb --strict` / `synapsedb repair codegraph.synapsedb --fast`

> 生产建议先 `--dry-run` 评估影响面，再执行实际治理；尊重读者以避免中断长查询。

---

## 7. 快照一致性（长查询）

```ts
const results = await db.withSnapshot(async (snap) =>
  snap.find({ object: 'method:Auth#issueToken' }).followReverse('CALLS').all(),
);
```

> 在快照期间，manifest epoch 固定，后台 compaction/GC 不影响本次链路。

---

## 8. 性能基准与压测建议

- 生成样本：`synapsedb bench bench.synapsedb 10000 lsm`
- 关注 `stats` 输出中的 `pages/epoch/tombstones/walBytes/txIds` 变化
- 流式查询（分页/分批）避免一次性加载大结果集
- 日常以增量合并为主，定期 rewrite 提高压缩比

---

## 9. 运维脚本骨架（可复用）

```ts
// scripts/ops-auto-compact.mts
import { spawn } from 'node:child_process';

const args = [
  'auto-compact',
  'codegraph.synapsedb',
  '--mode=incremental',
  '--orders=SPO',
  '--min-merge=2',
  '--hot-threshold=1',
  '--max-primary=1',
  '--auto-gc',
];
spawn('synapsedb', args, { stdio: 'inherit' });
```

---

## 10. 清理与备份

- 备份：直接复制 `*.synapsedb` 与对应的 `*.synapsedb.pages/` 目录
- 清理：删除临时样本库 `*.synapsedb` / `*.synapsedb.pages/` / `*.synapsedb.wal`

---

## 11. 常见问题

- 链式结果与页面合并“看着不一致”？用 `withSnapshot` 固定 epoch，或避免在长查询期间触发治理
- 全局命令不可用？使用 `npm i -g .`，或 `pnpm setup` 配置 PNPM_HOME 后再 `pnpm add -g .`
- ESM 导入失败？确保工程 `"type":"module"` 或使用 `await import('synapsedb')`

---

到这里，你已完成一个小型代码知识图谱的构建：导入、查询、导出、运维与基准测试。接下来可以将导入阶段替换为你的静态分析器（AST/LSIF/语言服务器产物），或对接你的知识/文档库，扩展更多谓词与属性。
