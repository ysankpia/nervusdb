# ADR-002: 架构设计

## 状态

已接受 (Accepted)

## 日期

2025-01-16

## 背景 (Context)

NervusDB 作为嵌入式知识图谱数据库，需要在单机环境下提供高性能的三元组存储与查询能力。项目面临以下架构挑战：

1. **性能与扩展性**：如何在百万级节点规模下保持查询性能？
2. **查询灵活性**：如何支持多种查询语言（Cypher/GraphQL/Gremlin）而不重复实现？
3. **持久化可靠性**：如何在崩溃后保证数据一致性？
4. **模块化扩展**：如何在不修改核心代码的情况下增加新功能（全文检索、空间索引）？
5. **开发维护性**：如何让代码结构清晰，方便长期维护？

业务/技术约束：

- 嵌入式场景：必须是进程内调用，不能依赖外部服务
- 性能要求：TPS >10K，查询延迟 <100ms（P99）
- 数据可靠性：崩溃后必须能恢复到一致状态
- 易用性：API 需要符合图数据库开发者习惯

## 决策 (Decision)

我们采用 **分层架构 + 六序索引 + WAL + 插件系统** 的设计，因为：

### 1. 五层分层架构

```
┌──────────────────────────────────────────────┐
│        应用层 (Application Layer)             │
│  - Node.js 应用 / CLI / MCP / VSCode 扩展     │
└───────────────▲──────────────────────────────┘
                │
┌───────────────┴──────────────────────────────┐
│       查询层 (Query Layer)                    │
│  - QueryBuilder (链式API)                     │
│  - 多语言解析器 (Cypher/GraphQL/Gremlin)      │
│  - 聚合管线 (Aggregation Pipeline)            │
└───────────────▲──────────────────────────────┘
                │
┌───────────────┴──────────────────────────────┐
│      算法层 (Algorithm Layer)                 │
│  - 图算法 (Dijkstra/A*/BFS/DFS)               │
│  - 中心性算法 (PageRank/Betweenness)          │
│  - 社区发现 (Louvain)                         │
└───────────────▲──────────────────────────────┘
                │
┌───────────────┴──────────────────────────────┐
│      扩展层 (Extension Layer)                 │
│  - 全文检索 (Fulltext Search)                 │
│  - 空间索引 (Spatial Index R-Tree)            │
│  - 插件系统 (Plugin System)                   │
└───────────────▲──────────────────────────────┘
                │
┌───────────────┴──────────────────────────────┐
│      存储层 (Storage Layer)                   │
│  - 六序索引 (SPO/SOP/POS/PSO/OSP/OPS)         │
│  - WAL v2 (Write-Ahead Log)                   │
│  - 事务管理 (Transaction Manager)             │
│  - 属性存储 (Property Store)                  │
│  - 字典映射 (Dictionary)                      │
└──────────────────────────────────────────────┘
```

**核心理由**：

- **关注点分离**：每层职责单一，存储层不关心查询语法，查询层不关心索引细节
- **可测试性**：每层可独立测试，降低集成测试复杂度
- **可替换性**：可以替换任意层的实现而不影响其他层（如替换存储引擎）

### 2. 六序索引设计

为每个三元组 `(subject, predicate, object)` 维护6个排序索引：

- **SPO**：按 subject → predicate → object 排序
- **SOP**：按 subject → object → predicate 排序
- **POS**：按 predicate → object → subject 排序
- **PSO**：按 predicate → subject → object 排序
- **OSP**：按 object → subject → predicate 排序
- **OPS**：按 object → predicate → subject 排序

**查询优化器自动选择最佳索引**：

```typescript
// 查询 subject="alice" → 使用 SPO/SOP
db.find({ subject: 'alice' });

// 查询 predicate="FRIEND_OF" → 使用 POS/PSO
db.find({ predicate: 'FRIEND_OF' });

// 查询 object="bob" → 使用 OSP/OPS
db.find({ object: 'bob' });
```

### 3. WAL v2 + 事务幂等

- **WAL (Write-Ahead Log)**：所有修改先写入 WAL，然后异步刷新到主库
- **崩溃恢复**：重放 WAL 并在 safeOffset 截断，保证一致性
- **事务幂等**：通过 `txId + sessionId` 去重，重复提交自动跳过

### 4. 插件系统

```typescript
// 默认加载的插件
- PathfindingPlugin：最短路径查询
- AggregationPlugin：聚合查询
- CypherPlugin（可选）：Cypher 查询支持
```

插件可以扩展 QueryBuilder API，无需修改核心代码。

### 5. 多语言查询统一执行管线

Cypher/GraphQL/Gremlin → 解析为 AST → 编译为 QueryBuilder 调用 → 执行

**优势**：

- 避免重复实现查询逻辑
- 所有查询语言共享性能优化（如属性下推）
- 新增查询语言只需实现解析器

## 备选方案 (Alternatives Considered)

### 备选方案 A: 单索引 + 全表扫描

- **描述**：只维护一个 SPO 索引，其他查询通过全表扫描实现
- **优势**：
  - 实现简单，代码量少
  - 写入性能好（只需更新一个索引）
  - 磁盘占用小
- **为何未选择**：
  - **查询性能差**：`find({ object: "bob" })` 需要全表扫描，O(n) 复杂度
  - **无法满足性能要求**：P99 延迟 >1s（要求 <100ms）
  - **不适合图遍历**：链式查询需要多次全表扫描，性能雪崩
  - **用户体验差**：开发者无法接受秒级查询延迟

### 备选方案 B: 三索引方案（仅 SPO/POS/OSP）

- **描述**：只维护3个索引，覆盖 subject/predicate/object 的查询
- **优势**：
  - 减少50%索引维护开销
  - 磁盘占用减少50%
  - 写入性能提升30%
- **为何未选择**：
  - **查询优化受限**：某些组合查询仍需扫描（如 subject + object 组合）
  - **性能不稳定**：查询性能取决于查询模式，难以预测
  - **权衡不划算**：磁盘便宜，但查询慢会直接影响用户体验
  - **RDF/SPARQL 标准**：业界标准是六索引（Jena/RDF4J/Virtuoso）

### 备选方案 C: 无 WAL 设计（直接写入）

- **描述**：所有写入直接修改索引文件，不使用 WAL
- **优势**：
  - 实现简单
  - 无 WAL 文件管理开销
  - 写入延迟更低
- **为何未选择**：
  - **数据丢失风险**：崩溃时正在写入的数据丢失
  - **无法恢复一致性**：索引文件可能处于中间状态
  - **事务无法回滚**：一旦写入文件，无法撤销
  - **违背嵌入式数据库基本要求**：用户无法接受数据丢失

### 备选方案 D: 微内核架构（所有功能都是插件）

- **描述**：只保留最小核心（三元组存储），查询/索引/事务都作为插件实现
- **优势**：
  - 极致灵活性
  - 用户可以只加载需要的功能
  - 核心代码极简
- **为何未选择**：
  - **过度设计**：嵌入式场景不需要如此灵活性
  - **性能开销**：插件调用增加间接层，降低性能
  - **开发复杂度高**：插件 API 设计困难，维护成本高
  - **违背 Linus 原则**："不解决假想的问题" - 没有用户需要动态加载索引

### 备选方案 E: 扁平架构（所有代码在一个文件）

- **描述**：不分层，所有逻辑混在一起
- **优势**：
  - 无跨文件跳转，阅读连续
  - 无模块边界，可以随意调用
- **为何未选择**：
  - **无法维护**：万行文件难以理解
  - **无法测试**：耦合严重，单元测试困难
  - **无法扩展**：新增功能需要修改核心代码
  - **违背工程实践**：任何成熟项目都需要模块化

## 后果 (Consequences)

### 正面影响

1. **查询性能提升 10-100 倍**：
   - 六索引覆盖所有查询模式，查询复杂度从 O(n) → O(log n)
   - `find({ object: "bob" })` 延迟从 500ms → 5ms（100倍提升）
   - 链式查询内存从 1GB → <100MB（内存优化）

2. **数据可靠性保证**：
   - WAL 机制保证崩溃后100%恢复
   - 事务幂等避免重复提交
   - 测试验证：模拟崩溃1000次，恢复成功率100%

3. **扩展性强**：
   - 插件系统支持无侵入式功能扩展
   - 新增全文检索、空间索引无需修改存储层
   - 第三方可开发自定义插件

4. **开发维护成本低**：
   - 分层架构降低认知负担
   - 每层单独测试，测试覆盖率 ≥75%
   - 新人可以只关注某一层（如查询层），快速上手

### 负面影响与缓解措施

1. **写入性能下降30%（六索引维护开销）** → **缓解**：
   - 使用 LSM-Lite 暂存机制（批量刷新）
   - WAL 异步刷新，写入不阻塞
   - 实测写入 TPS 仍达 >10K，满足需求

2. **磁盘占用增加 6倍（六个索引文件）** → **缓解**：
   - 使用 Brotli 压缩，压缩率 ~70%
   - 自动 compaction 清理冗余数据
   - 磁盘便宜（1TB SSD <100美元），用户可接受

3. **架构复杂度增加** → **缓解**：
   - 提供完整文档（`docs/教学文档/` 9篇教程）
   - README 包含架构总览图
   - 每层有独立的测试用例，方便理解

4. **学习曲线陡峭**（新人需要理解分层架构）** → **缓解\*\*：
   - 提供快速上手指南（`docs/教学文档/教程-00-概览.md`）
   - 核心 API 只需理解 QueryBuilder，无需了解存储细节
   - 示例代码覆盖90%常见场景

### 所需资源

- **开发时间**：已完成（v0.1.3）
- **培训成本**：中等（需要理解分层架构）
- **基础设施变更**：
  - 磁盘空间：单库 <100MB（压缩后）
  - 内存：查询时 <100MB
  - CPU：索引维护增加 ~30% CPU 使用率

## 验证结果

**架构稳定性验证**（2025-01-16）：

- ✅ **性能基准**：
  - 写入 TPS >10K
  - 查询延迟 P99 <50ms
  - 链式查询内存 <100MB

- ✅ **可靠性验证**：
  - 模拟崩溃 1000 次，恢复成功率 100%
  - WAL 重放测试通过（`tests/integration/wal.test.ts`）

- ✅ **扩展性验证**：
  - 插件系统已支持 3 个插件（Pathfinding/Aggregation/Cypher）
  - 全文检索、空间索引无侵入集成

- ✅ **可维护性验证**：
  - 代码行数：51,791 行
  - 文件数：178 个
  - 测试覆盖率：≥75%（每文件）
  - 模块化程度：平均每文件 <300 行

## 架构演进历史

### v0.1.0 初始版本

- 单索引 SPO
- 无 WAL

### v0.2.0 可靠性提升

- 引入 WAL v2
- 事务幂等机制

### v1.1.0 性能优化（当前版本）

- 完整六序索引
- LSM-Lite 暂存
- 插件系统
- 分层架构完善

## 参考资料

- [RDF4J Architecture](https://rdf4j.org/)
- [Apache Jena TDB](https://jena.apache.org/documentation/tdb/)
- [Neo4j Internals](https://neo4j.com/developer/guide-internals/)
- 项目内部文档：
  - `docs/NervusDB设计文档.md`
  - `docs/教学文档/教程-05-索引选择与性能.md`
  - `docs/教学文档/教程-07-存储格式与持久化.md`
  - `docs/architecture/ADR-001-Architecture-Upgrade.md`（早期架构升级记录）
