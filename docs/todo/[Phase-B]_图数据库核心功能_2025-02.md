# [Phase-B] å›¾æ•°æ®åº“æ ¸å¿ƒåŠŸèƒ½

**æ—¶é—´å‘¨æœŸ**ï¼š2025å¹´2æœˆç¬¬1-3å‘¨ï¼ˆ3å‘¨ï¼‰
**ä¼˜å…ˆçº§**ï¼šP1ï¼ˆé‡è¦ï¼‰
**å‰ç½®ä¾èµ–**ï¼šPhase-A å®Œæˆ
**ç›®æ ‡**ï¼šè¡¥é½ä½œä¸ºå›¾æ•°æ®åº“çš„æ ¸å¿ƒèƒ½åŠ›

## ğŸ“Š ä»»åŠ¡æ¸…å•

### 1. èŠ‚ç‚¹æ ‡ç­¾ç³»ç»Ÿ â­â­â­â­

#### 1.1 éœ€æ±‚åˆ†æ

- **ç°çŠ¶**ï¼šèŠ‚ç‚¹åªèƒ½é€šè¿‡IDæˆ–å±æ€§åŒºåˆ†ï¼Œæ— æ³•æŒ‰ç±»å‹åˆ†ç»„
- **ç›®æ ‡**ï¼šæ”¯æŒNeo4jé£æ ¼çš„èŠ‚ç‚¹æ ‡ç­¾ï¼Œå¦‚ `(:Person)`, `(:Company)`
- **ä»·å€¼**ï¼šå¤§å¹…ç®€åŒ–å›¾æ¨¡å¼æŸ¥è¯¢ï¼Œæå‡æŸ¥è¯¢è¡¨è¾¾åŠ›

#### 1.2 è®¾è®¡æ–¹æ¡ˆ

```typescript
// èŠ‚ç‚¹æ ‡ç­¾ç´¢å¼•ç»“æ„
interface LabelIndex {
  // æ ‡ç­¾ -> èŠ‚ç‚¹IDé›†åˆ
  labelToNodes: Map<string, Set<number>>;
  // èŠ‚ç‚¹ID -> æ ‡ç­¾é›†åˆ
  nodeToLabels: Map<number, Set<string>>;
}

// æ‰©å±• addFact API
interface NodeWithLabels {
  labels?: string[];
  properties?: Record<string, any>;
}

// ä½¿ç”¨ç¤ºä¾‹
db.addFact(
  { subject: 'alice', predicate: 'KNOWS', object: 'bob' },
  {
    subjectProperties: {
      labels: ['Person', 'Developer'],
      age: 30,
    },
    objectProperties: {
      labels: ['Person', 'Manager'],
      age: 35,
    },
  },
);
```

#### 1.3 å®æ–½ä»»åŠ¡

- [ ] è®¾è®¡æ ‡ç­¾å­˜å‚¨æ ¼å¼ï¼ˆ`.labels` æ–‡ä»¶ï¼‰
- [ ] å®ç° `LabelIndex` ç±»
- [ ] æ‰©å±• `addFact` æ”¯æŒæ ‡ç­¾å‚æ•°
- [ ] æ·»åŠ  `findByLabel()` æŸ¥è¯¢æ–¹æ³•
- [ ] å®ç°æ ‡ç­¾çš„å¢åˆ æ”¹æ“ä½œ
- [ ] æ ‡ç­¾ç´¢å¼•çš„æŒä¹…åŒ–ä¸æ¢å¤

#### 1.4 æŸ¥è¯¢APIè®¾è®¡

```typescript
// æŒ‰æ ‡ç­¾æŸ¥è¯¢
db.findByLabel('Person')
  .where((n) => n.properties.age > 25)
  .all();

// å¤šæ ‡ç­¾æŸ¥è¯¢
db.findByLabels(['Person', 'Developer']).follow('WORKS_AT').all();

// æ¨¡å¼åŒ¹é…ï¼ˆæœªæ¥ï¼‰
db.match().node('p', ['Person']).edge('->', 'KNOWS').node('q', ['Person']).return(['p', 'q']);
```

---

### 2. å˜é•¿è·¯å¾„æŸ¥è¯¢ â­â­â­â­â­

#### 2.1 éœ€æ±‚åˆ†æ

- **ç°çŠ¶**ï¼šåªæ”¯æŒå•è·³ `follow()` å’Œ `followReverse()`
- **ç›®æ ‡**ï¼šæ”¯æŒ `[*1..5]` é£æ ¼çš„å˜é•¿è·¯å¾„æŸ¥è¯¢
- **ä»·å€¼**ï¼šå®ç°æœ€çŸ­è·¯å¾„ã€æ‰€æœ‰è·¯å¾„ç­‰æ ¸å¿ƒå›¾ç®—æ³•

#### 2.2 ç®—æ³•è®¾è®¡

```typescript
// å˜é•¿è·¯å¾„é…ç½®
interface PathConfig {
  minHops: number; // æœ€å°è·³æ•°
  maxHops: number; // æœ€å¤§è·³æ•°
  uniqueness?: 'NODE' | 'EDGE' | 'NONE'; // å”¯ä¸€æ€§çº¦æŸ
  predicates?: string[]; // å…è®¸çš„è¾¹ç±»å‹
}

// BFSå®ç°å˜é•¿è·¯å¾„
class PathFinder {
  findPaths(from: number, to: number | undefined, config: PathConfig): Path[] {
    const queue: QueueItem[] = [
      {
        node: from,
        path: [],
        visitedNodes: new Set([from]),
        depth: 0,
      },
    ];

    const results: Path[] = [];

    while (queue.length > 0) {
      const current = queue.shift()!;

      // æ£€æŸ¥æ˜¯å¦æ»¡è¶³æœ€å°æ·±åº¦
      if (current.depth >= config.minHops) {
        if (!to || current.node === to) {
          results.push(current.path);
        }
      }

      // ç»§ç»­æ‰©å±•ç›´åˆ°æœ€å¤§æ·±åº¦
      if (current.depth < config.maxHops) {
        const edges = this.getOutEdges(current.node, config.predicates);

        for (const edge of edges) {
          // æ£€æŸ¥å”¯ä¸€æ€§çº¦æŸ
          if (config.uniqueness === 'NODE' && current.visitedNodes.has(edge.target)) {
            continue;
          }

          queue.push({
            node: edge.target,
            path: [...current.path, edge],
            visitedNodes: new Set([...current.visitedNodes, edge.target]),
            depth: current.depth + 1,
          });
        }
      }
    }

    return results;
  }
}
```

#### 2.3 APIè®¾è®¡

```typescript
// åŸºç¡€å˜é•¿è·¯å¾„
db.find({ subject: 'Alice' }).followPath('KNOWS', { min: 1, max: 3 }).all();

// æŸ¥æ‰¾æœ€çŸ­è·¯å¾„
db.shortestPath('Alice', 'Bob', {
  predicates: ['KNOWS', 'WORKS_WITH'],
  maxHops: 5,
});

// æŸ¥æ‰¾æ‰€æœ‰è·¯å¾„
db.allPaths('Alice', 'Bob', {
  minHops: 2,
  maxHops: 4,
  uniqueness: 'NODE',
});
```

#### 2.4 å®æ–½ä»»åŠ¡

- [ ] å®ç° BFS/DFS è·¯å¾„éå†ç®—æ³•
- [ ] æ·»åŠ  `followPath()` æ–¹æ³•åˆ° QueryBuilder
- [ ] å®ç°è·¯å¾„å”¯ä¸€æ€§çº¦æŸ
- [ ] æ·»åŠ æœ€çŸ­è·¯å¾„ç®—æ³•ï¼ˆDijkstraï¼‰
- [ ] æ€§èƒ½ä¼˜åŒ–ï¼šåŒå‘BFS
- [ ] è·¯å¾„ç»“æœçš„æ ¼å¼åŒ–è¾“å‡º

---

### 3. èšåˆå‡½æ•°æ¡†æ¶ â­â­â­â­

#### 3.1 éœ€æ±‚åˆ†æ

- **ç°çŠ¶**ï¼šæ— èšåˆèƒ½åŠ›ï¼Œåªèƒ½åœ¨åº”ç”¨å±‚å¤„ç†
- **ç›®æ ‡**ï¼šæ”¯æŒ COUNT, SUM, AVG, MIN, MAX, GROUP BY
- **ä»·å€¼**ï¼šå®ç°æ•°æ®åˆ†æå’Œç»Ÿè®¡æŸ¥è¯¢

#### 3.2 èšåˆç®¡é“è®¾è®¡

```typescript
// èšåˆé˜¶æ®µå®šä¹‰
interface AggregationStage {
  type: 'GROUP' | 'COUNT' | 'SUM' | 'AVG' | 'MIN' | 'MAX';
  field?: string;
  alias: string;
}

// èšåˆæ‰§è¡Œå™¨
class AggregationPipeline {
  private stages: AggregationStage[] = [];

  groupBy(fields: string[]): this {
    this.stages.push({
      type: 'GROUP',
      field: fields.join(','),
      alias: '_group',
    });
    return this;
  }

  count(alias = 'count'): this {
    this.stages.push({ type: 'COUNT', alias });
    return this;
  }

  sum(field: string, alias: string): this {
    this.stages.push({ type: 'SUM', field, alias });
    return this;
  }

  avg(field: string, alias: string): this {
    this.stages.push({ type: 'AVG', field, alias });
    return this;
  }

  execute(): AggregateResult[] {
    // åˆ†ç»„é˜¶æ®µ
    const groups = this.executeGrouping();

    // èšåˆé˜¶æ®µ
    return groups.map((group) => {
      const result: any = { _group: group.key };

      for (const stage of this.stages) {
        if (stage.type === 'COUNT') {
          result[stage.alias] = group.items.length;
        } else if (stage.type === 'SUM') {
          result[stage.alias] = group.items.reduce((sum, item) => sum + item[stage.field!], 0);
        }
        // ... å…¶ä»–èšåˆå‡½æ•°
      }

      return result;
    });
  }
}
```

#### 3.3 APIä½¿ç”¨ç¤ºä¾‹

```typescript
// ç»Ÿè®¡æ¯ä¸ªäººçš„æœ‹å‹æ•°é‡
db.aggregate().match({ predicate: 'KNOWS' }).groupBy(['subject']).count('friendCount').execute();

// è®¡ç®—æ¯ä¸ªéƒ¨é—¨çš„å¹³å‡å¹´é¾„
db.aggregate()
  .match({ predicate: 'WORKS_AT' })
  .groupBy(['object'])
  .avg('subjectProperties.age', 'avgAge')
  .execute();

// å¤æ‚èšåˆï¼šæŒ‰æ ‡ç­¾å’Œå¹´é¾„æ®µåˆ†ç»„
db.aggregate()
  .matchByLabel('Person')
  .addField('ageGroup', (n) => Math.floor(n.properties.age / 10) * 10)
  .groupBy(['label', 'ageGroup'])
  .count('count')
  .avg('properties.salary', 'avgSalary')
  .execute();
```

#### 3.4 å®æ–½ä»»åŠ¡

- [ ] è®¾è®¡èšåˆç®¡é“æ¶æ„
- [ ] å®ç°åŸºç¡€èšåˆå‡½æ•°ï¼ˆCOUNT, SUM, AVGï¼‰
- [ ] å®ç° GROUP BY åˆ†ç»„é€»è¾‘
- [ ] æ·»åŠ  MIN/MAX å‡½æ•°
- [ ] ä¼˜åŒ–å†…å­˜ä½¿ç”¨ï¼ˆæµå¼èšåˆï¼‰
- [ ] èšåˆç»“æœçš„æ’åºå’Œé™åˆ¶

---

## ğŸ“ˆ æ€§èƒ½ç›®æ ‡

| åŠŸèƒ½      | æ•°æ®è§„æ¨¡            | ç›®æ ‡æ€§èƒ½ |
| --------- | ------------------- | -------- |
| æ ‡ç­¾æŸ¥è¯¢  | 100ä¸‡èŠ‚ç‚¹ï¼Œ10ä¸ªæ ‡ç­¾ | < 10ms   |
| 3è·³è·¯å¾„   | 10ä¸‡èŠ‚ç‚¹            | < 100ms  |
| 5è·³è·¯å¾„   | 10ä¸‡èŠ‚ç‚¹            | < 500ms  |
| COUNTèšåˆ | 100ä¸‡è®°å½•           | < 200ms  |
| GROUP BY  | 100ä¸‡è®°å½•ï¼Œ1000ç»„   | < 500ms  |

## ğŸ§ª æµ‹è¯•è®¡åˆ’

### åŠŸèƒ½æµ‹è¯•

```typescript
describe('èŠ‚ç‚¹æ ‡ç­¾ç³»ç»Ÿ', () => {
  it('æ”¯æŒå¤šæ ‡ç­¾èŠ‚ç‚¹', () => {
    db.addNode('alice', {
      labels: ['Person', 'Developer', 'TeamLead'],
      properties: { age: 30 },
    });

    expect(db.findByLabel('Person')).toContainNode('alice');
    expect(db.findByLabel('Developer')).toContainNode('alice');
  });

  it('æ”¯æŒæ ‡ç­¾ç´¢å¼•æŸ¥è¯¢', () => {
    // åˆ›å»º1000ä¸ªèŠ‚ç‚¹ï¼Œ100ä¸ªPerson
    const persons = db.findByLabel('Person').all();
    expect(persons).toHaveLength(100);
  });
});

describe('å˜é•¿è·¯å¾„æŸ¥è¯¢', () => {
  it('æ‰¾åˆ°æ‰€æœ‰2-4è·³è·¯å¾„', () => {
    const paths = db.find({ subject: 'A' }).followPath('LINK', { min: 2, max: 4 }).all();

    expect(paths.every((p) => p.length >= 2 && p.length <= 4)).toBe(true);
  });

  it('æœ€çŸ­è·¯å¾„æ­£ç¡®', () => {
    const path = db.shortestPath('A', 'E', { maxHops: 10 });
    expect(path).toHaveLength(3); // A->B->D->E
  });
});

describe('èšåˆå‡½æ•°', () => {
  it('COUNTç»Ÿè®¡æ­£ç¡®', () => {
    const result = db
      .aggregate()
      .match({ predicate: 'KNOWS' })
      .groupBy(['subject'])
      .count('friends')
      .execute();

    expect(result).toContainEqual({
      _group: 'Alice',
      friends: 5,
    });
  });
});
```

## ğŸ“ è®¾è®¡æ–‡æ¡£

### æ ‡ç­¾ç³»ç»Ÿå­˜å‚¨æ ¼å¼

```
.labels æ–‡ä»¶ç»“æ„:
[Header: 8 bytes]
  - Magic: 4 bytes ('LABL')
  - Version: 2 bytes
  - Count: 2 bytes

[Label Entries]
  - LabelID: 2 bytes
  - NameLength: 2 bytes
  - Name: variable

[Node-Label Mappings]
  - NodeID: 4 bytes
  - LabelCount: 1 byte
  - LabelIDs: variable
```

### è·¯å¾„æŸ¥è¯¢ä¼˜åŒ–ç­–ç•¥

1. **åŒå‘BFS**ï¼šä»èµ·ç‚¹å’Œç»ˆç‚¹åŒæ—¶æœç´¢
2. **å‰ªæç­–ç•¥**ï¼šåŸºäºå·²çŸ¥æœ€çŸ­è·¯å¾„é•¿åº¦å‰ªæ
3. **ç¼“å­˜æœºåˆ¶**ï¼šç¼“å­˜é«˜é¢‘æŸ¥è¯¢çš„è·¯å¾„ç»“æœ
4. **å¹¶è¡ŒåŒ–**ï¼šå¤šçº¿ç¨‹å¹¶è¡Œæ‰©å±•ä¸åŒåˆ†æ”¯

## âœ… å®Œæˆæ ‡å‡†

- [ ] æ‰€æœ‰æ–°åŠŸèƒ½æœ‰å®Œæ•´æµ‹è¯•è¦†ç›–
- [ ] æ€§èƒ½åŸºå‡†æµ‹è¯•é€šè¿‡
- [ ] APIæ–‡æ¡£æ›´æ–°
- [ ] å‘åå…¼å®¹æ€§ä¿è¯
- [ ] ç¤ºä¾‹ä»£ç ç¼–å†™å®Œæˆ

## ğŸš€ ä¸‹ä¸€æ­¥

å®Œæˆ Phase-B åï¼Œè¿›å…¥ Phase-C å·¥ç¨‹åŒ–ä¸è´¨é‡æå‡é˜¶æ®µã€‚
