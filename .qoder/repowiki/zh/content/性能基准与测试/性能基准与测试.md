# 性能基准与测试

<cite>
**本文档引用文件**  
- [basic.mjs](file://benchmarks/basic.mjs)
- [comprehensive.mjs](file://benchmarks/comprehensive.mjs)
- [insert_scan.mjs](file://benchmarks/insert_scan.mjs)
- [path_agg.mjs](file://benchmarks/path_agg.mjs)
- [framework.mjs](file://benchmarks/framework.mjs)
- [quick.mjs](file://benchmarks/quick.mjs)
- [bench-standard.mjs](file://scripts/bench-standard.mjs)
- [performance_baseline.test.ts](file://tests/performance/performance_baseline.test.ts)
- [performance_large_insert.test.ts](file://tests/performance/performance_large_insert.test.ts)
- [property_index_performance.test.ts](file://tests/performance/property_index_performance.test.ts)
- [synapseDb.ts](file://src/synapseDb.ts)
- [persistentStore.ts](file://src/storage/persistentStore.ts)
- [propertyIndex.ts](file://src/storage/propertyIndex.ts)
- [suites.ts](file://src/benchmark/suites.ts)
- [community.ts](file://src/algorithms/community.ts)
</cite>

## 更新摘要
**变更内容**   
- 在“关键路径性能分析”部分新增了关于Louvain社区发现算法的说明，解释其行为变更及对性能测试的影响。
- 更新了相关代码文件的引用来源，包括 `suites.ts` 和 `community.ts`。
- 保持原有文档结构和其余内容不变。

## 目录
1. [简介](#简介)
2. [基准测试脚本说明](#基准测试脚本说明)
3. [标准性能测试执行方法](#标准性能测试执行方法)
4. [报告指标解读](#报告指标解读)
5. [关键路径性能分析](#关键路径性能分析)
6. [性能调优建议](#性能调优建议)
7. [结论](#结论)

## 简介
SynapseDB 是一个高性能图数据库系统，支持大规模三元组存储、属性索引、复杂图查询和聚合操作。为确保其在不同硬件环境下的稳定性和可预测性，项目提供了完整的性能基准测试体系。

本文档旨在提供一套可复现的性能测试方法论，帮助开发者和用户理解系统的性能特征，识别潜在瓶颈，并根据实际应用场景进行针对性优化。通过标准化的测试流程和详尽的结果分析，用户可以在目标部署环境中获得真实可靠的性能预期。

## 基准测试脚本说明
项目 `benchmarks` 目录下提供了多种类型的基准测试脚本，用于评估不同工作负载下的系统表现。

### 基础写入吞吐量测试 (basic.mjs)
该脚本测量最基础的三元组插入性能和全表扫描效率。它创建一个临时数据库，批量插入 5000 条三元组（如 `u0 KNOWS v0`），然后执行一次全量扫描查询。

```mermaid
flowchart TD
Start([开始]) --> CreateDB["创建临时数据库"]
CreateDB --> Insert["批量插入 5000 条三元组"]
Insert --> Flush["刷盘持久化"]
Flush --> ScanAll["全量扫描查询"]
ScanAll --> CloseDB["关闭并清理数据库"]
CloseDB --> End([结束])
```

**测试重点**
- 小规模数据的写入延迟
- 内存到磁盘的同步效率
- 全表扫描的 I/O 性能

**代码路径**
- 插入逻辑: `db.addFact()` 批量调用
- 持久化: `await db.flush()`
- 查询: `db.find({ predicate: 'KNOWS' }).toArray()`

**相关文件**
- [basic.mjs](file://benchmarks/basic.mjs)

### 综合混合负载测试 (comprehensive.mjs)
这是最全面的性能套件，模拟了现实世界中典型的混合读写场景。它使用自定义的 `BenchmarkSuite` 框架，包含多个子套件：

1.  **数据插入性能测试**: 测试小、中、大规模数据集的插入速度及内存占用。
2.  **查询性能测试**: 覆盖精确查询、模式匹配、流式处理和链式联想等。
3.  **图算法性能测试**: 评估最短路径（BFS、双向BFS、Dijkstra）等核心图算法的执行效率。
4.  **聚合性能测试**: 测试 COUNT、AVG、SUM 等聚合函数以及流式聚合的性能。

```mermaid
graph TB
subgraph "综合基准套件"
A[插入性能]
B[查询性能]
C[图算法]
D[聚合性能]
end
A --> |生成数据| E[(测试数据库)]
B --> |读取数据| E
C --> |读取数据| E
D --> |读取数据| E
E --> F[生成JSON报告]
```

**特点**
- 支持 GC 指标收集（需 `--expose-gc`）
- 包含预热运行和多次测量以提高准确性
- 输出详细的 JSON 格式报告，便于自动化分析

**相关文件**
- [comprehensive.mjs](file://benchmarks/comprehensive.mjs)
- [framework.mjs](file://benchmarks/framework.mjs)

### 扫描性能评估 (insert_scan.mjs)
此脚本专注于评估大规模插入后的查询性能，特别是扫描操作的效率。它允许通过命令行参数指定数据规模（默认 20,000 条）。

**测试流程**
1.  **插入**: 快速插入 N 条三元组（主语循环使用 1000 个 ID）。
2.  **刷盘**: 显式调用 `flush()` 将数据持久化。
3.  **全扫描**: 执行 `find({ predicate: 'KNOWS' })` 获取所有匹配记录。
4.  **过滤扫描**: 执行 `find({ subject: 'user1', predicate: 'KNOWS' })` 进行带条件的扫描。

该脚本清晰地分离了写入、持久化和读取阶段，有助于分析每个环节的耗时。

**相关文件**
- [insert_scan.mjs](file://benchmarks/insert_scan.mjs)

### 其他专用测试脚本
- **path_agg.mjs**: 专门测试变长路径查询和聚合管道的性能。
- **quick.mjs**: 快速验证脚本，用于开发过程中的即时性能检查。

## 标准性能测试执行方法
推荐使用 `scripts/bench-standard.mjs` 脚本来运行标准性能测试，因为它提供了一个简单且一致的测试流程。

### 执行步骤
1.  **准备环境**: 确保 Node.js 环境已安装，并克隆 SynapseDB 仓库。
2.  **编译项目**: 运行 `npm run build` 或 `pnpm build` 以生成 `dist` 目录下的编译文件。
3.  **运行脚本**: 在项目根目录下执行以下命令：
    ```bash
    node scripts/bench-standard.mjs <数据库路径> [--count=100000] [--limit=1000]
    ```
    - `<数据库路径>`: 指定要创建或使用的数据库文件路径（例如 `./test.db`）。
    - `--count`: 可选，指定要生成的三元组数量，默认为 100,000。
    - `--limit`: 可选，指定查询结果的返回条数限制，默认为 1,000。

### 示例输出
```text
生成数据 100000 条...
insert: 1234ms
flush: 567ms
pattern.query: 89ms
pattern.hits 1000
cypher.query: 234ms
cypher.hits 1000
```

该脚本会自动完成数据生成、持久化，并对比 PatternBuilder API 和 Cypher 查询引擎的性能。

**相关文件**
- [bench-standard.mjs](file://scripts/bench-standard.mjs)

## 报告指标解读
性能测试报告中的关键指标对于评估系统健康状况至关重要。

### QPS (Queries Per Second)
QPS 衡量系统每秒能够处理的查询请求数。在 `bench-standard.mjs` 中，可以通过总查询时间估算：
```
QPS = --limit 的值 / 查询耗时(秒)
```
例如，如果 `pattern.query` 耗时 89ms 返回 1000 条，则 QPS ≈ 1000 / 0.089 ≈ 11,236。

### 延迟分布
延迟是指从发出请求到收到响应所花费的时间。`comprehensive.mjs` 会记录每次测量的耗时。关注点包括：
- **平均延迟**: 所有运行时间的算术平均值。
- **P95/P99 延迟**: 95% 或 99% 的请求都在此时间内完成，更能反映用户体验。
- **最大延迟**: 最慢的一次查询耗时，可能暴露偶发的性能问题。

### 内存增长
内存使用是衡量系统资源消耗的关键指标。`property_index_performance.test.ts` 中的测试明确监控了内存变化：
- **初始内存**: 数据库打开前的堆内存使用量。
- **插入后内存**: 大量数据插入并持久化后的堆内存使用量。
- **内存增量**: 两者之差，应保持在一个合理的范围内（例如，插入 5000 条记录后增长小于 100MB）。

异常的内存增长可能表明存在内存泄漏或缓存未正确管理。

**相关文件**
- [property_index_performance.test.ts](file://tests/performance/property_index_performance.test.ts)

## 关键路径性能分析
通过对 `tests/performance` 目录下的测试用例进行分析，可以识别出系统的关键性能瓶颈。

### 属性索引查询效率
`property_index_performance.test.ts` 是分析属性索引性能的核心文件。它验证了以下关键路径：

1.  **索引构建**: 使用 `rebuildIndexes: true` 选项打开数据库，强制重建属性索引。测试插入 10,000 条带复杂属性的数据，并测量总耗时。
2.  **等值查询**: `findByNodeProperty({ propertyName: 'age', value: 25 })` 应在 100ms 内完成。
3.  **范围查询**: `findByNodeProperty({ propertyName: 'age', range: { min: 20, max: 30 } })` 应在 200ms 内

### Louvain 社区发现算法性能
根据最近的提交 `21f84befede70979fd5379697b2b212ab6045ffd`，Louvain 社区发现算法的行为发生了变更，解决了因死循环导致的挂起问题。这一修改直接影响了 `graphAlgorithmsSuite` 中的 `社区发现` 基准测试。

在 `src/benchmark/suites.ts` 文件中，`graphAlgorithmsSuite` 定义了一个名为 `社区发现` 的基准测试，该测试使用 `LouvainCommunityDetection` 类来检测图中的社区结构。为了避免在图折叠阶段出现无限循环，现在添加了防御性编程检查：当图没有被成功折叠（即节点数未减少）时，将提前退出循环。

```typescript
// 防御性编程：如果图没有被折叠（节点数未减少），则跳出循环避免死循环
if (currentNodeCount === previousNodeCount) {
  break;
}
```

此更改确保了即使在某些极端情况下，算法也能正常终止，从而保证了性能测试的可靠性和可重复性。

**相关文件**
- [suites.ts](file://src/benchmark/suites.ts)
- [community.ts](file://src/algorithms/community.ts)

## 性能调优建议
提供调优建议，包括预分配空间、调整段大小、启用压缩等。鼓励用户在目标硬件上运行基准测试以获得真实性能预期。

## 结论
通过上述基准测试和性能分析，我们可以全面了解 SynapseDB 在各种工作负载下的表现。结合具体的调优策略，用户可以根据自身需求优化数据库配置，以达到最佳性能。