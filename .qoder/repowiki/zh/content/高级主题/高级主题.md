<docs>
# 高级主题

<cite>
**本文档中引用的文件**
- [suite.ts](file://src/algorithms/suite.ts)
- [minHeap.ts](file://src/utils/minHeap.ts)
- [lock.ts](file://src/utils/lock.ts)
- [enhanced.ts](file://src/types/enhanced.ts)
- [persistentStore.ts](file://src/storage/persistentStore.ts)
- [community.ts](file://src/algorithms/community.ts) - *Louvain算法死循环修复*
- [types.ts](file://src/algorithms/types.ts) - *社区发现相关类型定义*
- [suites.ts](file://src/benchmark/suites.ts) - *基准测试套件实现，含代码风格修复*
</cite>

## 更新摘要
**变更内容**
- 更新了图算法模块中Louvain社区发现算法的稳定性说明，增加了对无限循环防御机制的描述
- 新增了关于`buildCommunityGraph`方法当前简化实现状态的说明
- 更新了相关代码文件的引用来源，标记了最近修改的文件
- 保持文档其他部分不变，因为只有社区发现算法部分受到了代码变更的影响
- 新增了对基准测试套件文件`suites.ts`的引用，该文件近期进行了代码风格修复和lint规则调整

## 目录
1. [图算法模块高级分析能力](#图算法模块高级分析能力)
2. [路径规划中的最小堆优先级调度机制](#路径规划中的最小堆优先级调度机制)
3. [高并发环境下的读写锁同步策略](#高并发环境下的读写锁同步策略)
4. [增强类型系统支持精确类型推断](#增强类型系统支持精确类型推断)
5. [组件调用与自定义插件扩展](#组件调用与自定义插件扩展)
6. [性能敏感场景最佳实践](#性能敏感场景最佳实践)

## 图算法模块高级分析能力

`algorithms` 模块提供了完整的图分析能力，通过 `GraphAlgorithmSuiteImpl` 类统一暴露各类高级算法接口。该套件实现了 `GraphAlgorithmSuite` 接口，包含中心性计算、社区发现、相似度度量和图结构分析四大功能域。

在中心性计算方面，系统实现了 PageRank、中介中心性（Betweenness）、接近中心性（Closeness）、度中心性和特征向量中心性等多种算法。这些算法通过工厂模式 `CentralityAlgorithmFactory` 创建实例，采用统一的 `compute` 方法执行计算，返回标准化的 `CentralityResult` 结构。

社区发现功能支持 Louvain 算法、标签传播（Label Propagation）以及连通分量检测。其中 Louvain 算法可用于大规模网络的层次化社区划分，而强连通分量检测则基于深度优先搜索实现，适用于有向图的环路分析。

相似度度量提供 Jaccard 相似度、余弦相似度、Adamic-Adar 和优先连接等指标，用于评估节点间的关联强度。这些算法均通过 `SimilarityAlgorithmFactory` 工厂创建，并由 `CompositeSimilarityAlgorithm` 支持多算法加权组合。

图分析组件还包含桥边检测、关节点识别、环路检测和拓扑排序等图论基础算法，为复杂网络分析提供底层支持。

**更新** 在最新版本中，Louvain 社区发现算法已添加防御性检查以防止无限循环。当图折叠未导致节点数减少时，算法会主动跳出循环，提升了算法的稳定性和可靠性。

```mermaid
classDiagram
class LouvainCommunityDetection {
+detectCommunities(graph : Graph, options? : LouvainOptions) : CommunityResult
+calculateModularity(graph : Graph, communities : Map<string, number>) : number
-private louvainPhaseOne(...) : {newCommunities : Map<string, number>, improved : boolean}
-private calculateModularityGain(...) : number
-private buildCommunityGraph(graph : Graph, communities : Map<string, number>) : Graph
}
class CommunityDetectionAlgorithm {
+detectCommunities(graph : Graph, options? : AlgorithmOptions) : CommunityResult
+calculateModularity(graph : Graph, communities : Map<string, number>) : number
}
class CommunityResult {
+communities : Map<string, number>
+hierarchy : CommunityLevel[]
+modularity : number
+communityCount : number
}
class CommunityLevel {
+level : number
+communities : Map<string, number>
+modularity : number
}
LouvainCommunityDetection ..|> CommunityDetectionAlgorithm
```

**图表来源**
- [community.ts](file://src/algorithms/community.ts#L19-L267) - *Louvain算法实现，含死循环防护*
- [types.ts](file://src/algorithms/types.ts#L255-L261) - *社区发现算法接口定义*

**章节来源**
- [suite.ts](file://src/algorithms/suite.ts#L61-L406)
- [types.ts](file://src/algorithms/types.ts#L274-L316)
- [centrality.ts](file://src/algorithms/centrality.ts#L593-L650)
- [similarity.ts](file://src/algorithms/similarity.ts#L618-L691)
- [community.ts](file://src/algorithms/community.ts#L19-L267) - *更新：Louvain算法稳定性改进*

## 路径规划中的最小堆优先级调度机制

路径规划算法依赖 `MinHeap` 数据结构实现高效的优先级调度。该最小堆类位于 `utils/minHeap.ts`，采用数组存储二叉堆结构，通过比较函数 `compare` 支持泛型元素的自定义排序。

在 Dijkstra 最短路径算法中，`MinHeap` 作为优先队列使用，确保每次都能以 O(log n) 时间复杂度取出当前距离最短的节点。其核心操作包括：
- `push(item)`：插入元素并向上堆化，维持堆属性
- `pop()`：弹出堆顶元素并向下堆化，时间复杂度 O(log n)
- `peek()`：查看最小元素而不移除

堆化过程通过 `heapifyUp` 和 `heapifyDown` 方法实现，利用父子节点索引关系（父节点 i 的子节点为 2i+1 和 2i+2）进行位置调整。这种设计相比线性搜索的 O(n) 性能有显著提升，是高效路径查找的关键优化。

值得注意的是，在 `centrality.ts` 文件中存在一个同名但独立实现的 `MinHeap` 类，专用于特定中心性算法的内部计算，体现了针对不同场景的定制化优化思路。

```mermaid
classDiagram
class MinHeap~T~ {
-heap : T[]
-compare : (a : T, b : T) => number
+push(item : T) : void
+pop() : T | undefined
+isEmpty() : boolean
+size() : number
+peek() : T | undefined
-heapifyUp(index : number) : void
-heapifyDown(index : number) : void
-swap(i : number, j : number) : void
}
```

**图表来源**
- [minHeap.ts](file://src/utils/minHeap.ts#L4-L113)

**章节来源**
- [minHeap.ts](file://src/utils/minHeap.ts#L4-L113)
- [pathfinding.ts](file://src/algorithms/pathfinding.ts)

## 高并发环境下的读写锁同步策略

系统通过 `acquireLock` 函数实现进程级独占写锁，防止多个写入者同时访问同一数据库文件。该机制位于 `utils/lock.ts`，采用文件锁方式实现跨进程同步。

当启用锁机制时（`enableLock=true`），系统会在数据库路径后缀添加 `.lock` 文件。通过 `fs.open(lockPath, 'wx')` 原子操作尝试创建该文件，若已存在则抛出异常，从而保证同一时刻只有一个写入者。

锁文件中记录了持有者的进程 ID 和启动时间，便于故障排查。系统注册了 `exit`、`SIGINT` 和 `SIGTERM` 信号处理器，在进程退出时自动释放锁资源，避免死锁问题。

在 `PersistentStore` 中，锁机制与 WAL（Write-Ahead Logging）协同工作。当存在写锁且 WAL 文件非空时，禁止无锁模式打开，防止并发写入风险。这种双重保护机制确保了数据一致性和完整性。

```mermaid
sequenceDiagram
participant Client as "客户端"
participant Store as "PersistentStore"
participant Lock as "文件锁系统"
Client->>