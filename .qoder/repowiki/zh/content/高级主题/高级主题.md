# 高级主题

<cite>
**本文档中引用的文件**
- [suite.ts](file://src/algorithms/suite.ts)
- [minHeap.ts](file://src/utils/minHeap.ts)
- [lock.ts](file://src/utils/lock.ts)
- [enhanced.ts](file://src/types/enhanced.ts)
- [persistentStore.ts](file://src/storage/persistentStore.ts)
- [community.ts](file://src/algorithms/community.ts) - *Louvain算法死循环修复*
- [types.ts](file://src/algorithms/types.ts) - *社区发现相关类型定义*
</cite>

## 更新摘要
**变更内容**
- 更新了图算法模块中Louvain社区发现算法的稳定性说明，增加了对无限循环防御机制的描述
- 新增了关于`buildCommunityGraph`方法当前简化实现状态的说明
- 更新了相关代码文件的引用来源，标记了最近修改的文件
- 保持文档其他部分不变，因为只有社区发现算法部分受到了代码变更的影响

## 目录
1. [图算法模块高级分析能力](#图算法模块高级分析能力)
2. [路径规划中的最小堆优先级调度机制](#路径规划中的最小堆优先级调度机制)
3. [高并发环境下的读写锁同步策略](#高并发环境下的读写锁同步策略)
4. [增强类型系统支持精确类型推断](#增强类型系统支持精确类型推断)
5. [组件调用与自定义插件扩展](#组件调用与自定义插件扩展)
6. [性能敏感场景最佳实践](#性能敏感场景最佳实践)

## 图算法模块高级分析能力

`algorithms` 模块提供了完整的图分析能力，通过 `GraphAlgorithmSuiteImpl` 类统一暴露各类高级算法接口。该套件实现了 `GraphAlgorithmSuite` 接口，包含中心性计算、社区发现、相似度度量和图结构分析四大功能域。

在中心性计算方面，系统实现了 PageRank、中介中心性（Betweenness）、接近中心性（Closeness）、度中心性和特征向量中心性等多种算法。这些算法通过工厂模式 `CentralityAlgorithmFactory` 创建实例，采用统一的 `compute` 方法执行计算，返回标准化的 `CentralityResult` 结构。

社区发现功能支持 Louvain 算法、标签传播（Label Propagation）以及连通分量检测。其中 Louvain 算法可用于大规模网络的层次化社区划分，而强连通分量检测则基于深度优先搜索实现，适用于有向图的环路分析。

相似度度量提供 Jaccard 相似度、余弦相似度、Adamic-Adar 和优先连接等指标，用于评估节点间的关联强度。这些算法均通过 `SimilarityAlgorithmFactory` 工厂创建，并由 `CompositeSimilarityAlgorithm` 支持多算法加权组合。

图分析组件还包含桥边检测、关节点识别、环路检测和拓扑排序等图论基础算法，为复杂网络分析提供底层支持。

**更新** 在最新版本中，Louvain 社区发现算法已添加防御性检查以防止无限循环。当图折叠未导致节点数减少时，算法会主动跳出循环，提升了算法的稳定性和可靠性。

```mermaid
classDiagram
class LouvainCommunityDetection {
+detectCommunities(graph : Graph, options? : LouvainOptions) : CommunityResult
+calculateModularity(graph : Graph, communities : Map<string, number>) : number
-private louvainPhaseOne(...) : {newCommunities : Map<string, number>, improved : boolean}
-private calculateModularityGain(...) : number
-private buildCommunityGraph(graph : Graph, communities : Map<string, number>) : Graph
}
class CommunityDetectionAlgorithm {
+detectCommunities(graph : Graph, options? : AlgorithmOptions) : CommunityResult
+calculateModularity(graph : Graph, communities : Map<string, number>) : number
}
class CommunityResult {
+communities : Map<string, number>
+hierarchy : CommunityLevel[]
+modularity : number
+communityCount : number
}
class CommunityLevel {
+level : number
+communities : Map<string, number>
+modularity : number
}
LouvainCommunityDetection ..|> CommunityDetectionAlgorithm
```

**Diagram sources**
- [community.ts](file://src/algorithms/community.ts#L19-L267) - *Louvain算法实现，含死循环防护*
- [types.ts](file://src/algorithms/types.ts#L255-L261) - *社区发现算法接口定义*

**Section sources**
- [suite.ts](file://src/algorithms/suite.ts#L61-L406)
- [types.ts](file://src/algorithms/types.ts#L274-L316)
- [centrality.ts](file://src/algorithms/centrality.ts#L593-L650)
- [similarity.ts](file://src/algorithms/similarity.ts#L618-L691)
- [community.ts](file://src/algorithms/community.ts#L19-L267) - *更新：Louvain算法稳定性改进*

## 路径规划中的最小堆优先级调度机制

路径规划算法依赖 `MinHeap` 数据结构实现高效的优先级调度。该最小堆类位于 `utils/minHeap.ts`，采用数组存储二叉堆结构，通过比较函数 `compare` 支持泛型元素的自定义排序。

在 Dijkstra 最短路径算法中，`MinHeap` 作为优先队列使用，确保每次都能以 O(log n) 时间复杂度取出当前距离最短的节点。其核心操作包括：
- `push(item)`：插入元素并向上堆化，维持堆属性
- `pop()`：弹出堆顶元素并向下堆化，时间复杂度 O(log n)
- `peek()`：查看最小元素而不移除

堆化过程通过 `heapifyUp` 和 `heapifyDown` 方法实现，利用父子节点索引关系（父节点 i 的子节点为 2i+1 和 2i+2）进行位置调整。这种设计相比线性搜索的 O(n) 性能有显著提升，是高效路径查找的关键优化。

值得注意的是，在 `centrality.ts` 文件中存在一个同名但独立实现的 `MinHeap` 类，专用于特定中心性算法的内部计算，体现了针对不同场景的定制化优化思路。

```mermaid
classDiagram
class MinHeap~T~ {
-heap : T[]
-compare : (a : T, b : T) => number
+push(item : T) : void
+pop() : T | undefined
+isEmpty() : boolean
+size() : number
+peek() : T | undefined
-heapifyUp(index : number) : void
-heapifyDown(index : number) : void
-swap(i : number, j : number) : void
}
```

**Diagram sources**
- [minHeap.ts](file://src/utils/minHeap.ts#L4-L113)

**Section sources**
- [minHeap.ts](file://src/utils/minHeap.ts#L4-L113)
- [pathfinding.ts](file://src/algorithms/pathfinding.ts)

## 高并发环境下的读写锁同步策略

系统通过 `acquireLock` 函数实现进程级独占写锁，防止多个写入者同时访问同一数据库文件。该机制位于 `utils/lock.ts`，采用文件锁方式实现跨进程同步。

当启用锁机制时（`enableLock=true`），系统会在数据库路径后缀添加 `.lock` 文件。通过 `fs.open(lockPath, 'wx')` 原子操作尝试创建该文件，若已存在则抛出异常，从而保证同一时刻只有一个写入者。

锁文件中记录了持有者的进程 ID 和启动时间，便于故障排查。系统注册了 `exit`、`SIGINT` 和 `SIGTERM` 信号处理器，在进程退出时自动释放锁资源，避免死锁问题。

在 `PersistentStore` 中，锁机制与 WAL（Write-Ahead Logging）协同工作。当存在写锁且 WAL 文件非空时，禁止无锁模式打开，防止并发写入风险。这种双重保护机制确保了数据一致性和完整性。

```mermaid
sequenceDiagram
participant Client as "客户端"
participant Store as "PersistentStore"
participant Lock as "文件锁系统"
Client->>Store : open(path, {enableLock : true})
Store->>Lock : 尝试创建 .lock 文件
alt 锁文件不存在
Lock-->>Store : 创建成功
Store->>Store : 获取锁句柄
Store-->>Client : 返回数据库实例
else 锁文件已存在
Lock-->>Store : 创建失败
Store-->>Client : 抛出"数据库正被占用"错误
end
```

**Diagram sources**
- [lock.ts](file://src/utils/lock.ts#L6-L41)
- [persistentStore.ts](file://src/storage/persistentStore.ts#L99-L238)

**Section sources**
- [lock.ts](file://src/utils/lock.ts#L6-L41)
- [persistentStore.ts](file://src/storage/persistentStore.ts#L54-L54)

## 增强类型系统支持精确类型推断

`enhanced.ts` 文件定义了泛型化的类型系统，为 SynapseDB 提供强类型的 API 支持。核心接口 `TypedSynapseDB` 使用泛型参数约束节点属性 `TNodeProps` 和边属性 `TEdgeProps`，实现编译时类型安全。

该系统支持：
- 类型安全的 Fact 操作：`addFact` 返回带有正确属性类型的 `TypedFactRecord`
- 泛型化查询构建器：`TypedQueryBuilder` 维护查询上下文的类型信息
- 属性过滤器类型：`TypedPropertyFilter` 支持基于具体值类型的条件筛选
- 标签查询：`findByLabel` 方法支持 AND/OR 逻辑模式

通过 `open` 工厂方法，用户可以指定自定义的节点和边属性接口，如社交网络中的 `PersonNode` 和 `RelationshipEdge`，或知识图谱中的 `EntityNode` 和 `KnowledgeEdge`。这种设计既保持了灵活性，又提供了严格的类型检查。

```mermaid
classDiagram
class TypedSynapseDB~TNodeProps, TEdgeProps~ {
+addFact(fact : TypedFactInput, options? : TypedFactOptions) : TypedFactRecord
+find(criteria : FactCriteria) : TypedQueryBuilder
+findByNodeProperty(filter : TypedPropertyFilter) : TypedQueryBuilder
+findByEdgeProperty(filter : TypedPropertyFilter) : TypedQueryBuilder
+findByLabel(labels : string[]) : TypedQueryBuilder
+getNodeProperties(nodeId : number) : TNodeProps | null
+setNodeProperties(nodeId : number, properties : TNodeProps) : void
}
class TypedQueryBuilder~TNodeProps, TEdgeProps~ {
+where(predicate : (record : TypedFactRecord) => boolean) : TypedQueryBuilder
+limit(count : number) : TypedQueryBuilder
+skip(count : number) : TypedQueryBuilder
+all() : TypedFactRecord[]
}
class TypedFactRecord~TNodeProps, TEdgeProps~ {
+subjectProperties? : TNodeProps
+objectProperties? : TNodeProps
+edgeProperties? : TEdgeProps
}
TypedSynapseDB --> TypedQueryBuilder : "返回"
TypedQueryBuilder --> TypedFactRecord : "返回"
```

**Diagram sources**
- [enhanced.ts](file://src/types/enhanced.ts#L141-L215)

**Section sources**
- [enhanced.ts](file://src/types/enhanced.ts#L141-L215)

## 组件调用与自定义插件扩展

各算法组件通过工厂模式组织，支持灵活的实例化和扩展。`GraphAlgorithmFactoryImpl` 提供 `createAlgorithmSuite(graph)` 方法，为指定图实例创建完整的算法套件。

上层功能通过 `createAlgorithmSuite` 函数获取算法接口，无需关心具体实现细节。这种依赖注入模式降低了耦合度，便于单元测试和功能替换。

对于自定义算法插件，系统可通过扩展工厂类或直接实现相应算法接口进行集成。例如，可创建新的 `SimilarityAlgorithm` 实现并注册到 `SimilarityAlgorithmFactory` 中，然后通过 `createComposite` 方法与其他算法组合使用。

基准测试模块 `benchmark/suites.ts` 展示了算法套件的实际调用方式，通过构造内存图 `MemoryGraph` 并注入测试数据来验证算法性能。

**Section sources**
- [suite.ts](file